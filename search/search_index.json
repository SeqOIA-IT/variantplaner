{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ariantPlaner","text":"<p>A toolkit to manage many variants from many samples, with limited resources.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/natir/variantplaner.git@0.3.0\n</code></pre> <p>With <code>uv</code>:</p> <pre><code>python -m pip install --user pipx\npipx install git+https://github.com/natir/variantplaner.git@0.3.0\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>This section presents basic usage. For a more complete exemple checkout our usage page.</p> <p>Warning</p> <p><code>variantplaner</code> doesn't support compressed VCFs. This is a downstream trouble we are aware of and sorry about.</p>"},{"location":"#extract-data-from-one-vcf-into-several-parquet-files","title":"Extract data from one vcf into several parquet files","text":"<p>With <code>variantplaner</code>, you can parse an input VCF and save the relevant data into several parquet files.</p> <pre><code>variantplaner vcf2parquet -i input.vcf -v variants.parquet -g genotypes.parquet -a annotations.parquet\n</code></pre> <ul> <li><code>-g</code> option isn't mandatory. If not set you will lose genotyping information, and if <code>GT</code> field is present in the input VCF then only heterozygote or homozygote variants will be kept.</li> <li><code>-a</code> option isn't mandatory. If not set you will lose \"INFO\" fields information.</li> </ul> <p>Genotypes encoding:</p> <code>gt</code> field in parquet file Meaning 0 variant not present 1 heterozygote 2 homozygote 3 no information (only used in transmission file)"},{"location":"#convert-parquet-files-back-to-vcf","title":"Convert parquet files back to vcf","text":"<pre><code>variantplaner parquet2vcf -i variants.parquet -g genotypes.parquet -o output.vcf\n</code></pre> <p><code>-g</code> option isn't mandatory if not set the information isn't added. This options has many options that control the behavior of this subcommand, we apologize for this complexity.</p>"},{"location":"#structuration-of-data","title":"Structuration of data","text":""},{"location":"#merge-variants","title":"Merge variants","text":"<p>Danger</p> <p>This command can have huge memory and disk usage</p> <pre><code>variantplaner struct -i variants/1.parquet -i variants/2.parquet -i variants/3.parquet \u2026 -i variants/n.parquet variants -o variants.parquet\n</code></pre> Tip <p>By default temporary files are written to /tmp, but you can set your <code>TMPDIR</code>, <code>TEMP</code> or <code>TMP</code> environment variables to change this behavior.</p> <p>This command uses the divide-and-conquer algorithm to perform variants merging. The <code>-b|--bytes-memory-limit</code> option controls the size (in bytes) of each file chunk. Empirically RAM usage will be ten times this limit.</p>"},{"location":"#partitioning-genotypes","title":"Partitioning genotypes","text":"Danger <p>This command can have huge disk usage</p> <pre><code>variantplaner struct -i genotypes/1.parquet -i genotypes/2.parquet -i genotypes/3.parquet \u2026 -i genotypes/n.parquet genotypes -p partition_prefix/\n</code></pre>"},{"location":"#annotations","title":"Annotations","text":"<p>You can export annotation fields from VCF or CSV/TSV files into parquet files. To do so, variantplaner provides the <code>annotations</code> subcommand.</p> <p>Command: <pre><code>variantplaner annotations -i $INPUT_FILE -o $OUTPUT_PARQUET $INPUT_TYPE [OPTIONS...]\n</code></pre></p> <p>Where:</p> <ul> <li><code>-i|--input-path</code> is the input file (required)</li> <li><code>-o|--output-path</code> is the output parquet file (required)</li> <li><code>$INPUT_TYPE</code> is whether VCF or CSV (see below for the different value types)</li> </ul> <p>Following OPTIONS are input type-specific (see below).</p>"},{"location":"#vcf-format","title":"VCF format","text":"<p>If you wish to export <code>CLNDN</code> and <code>AF_ESP</code> fields from <code>annotations.vcf</code> into <code>clinvar.parquet</code>, you can run the following command:</p> <pre><code>variantplaner annotations -i annotations.vcf -o clinvar.parquet vcf -r annot_id --info CLNDN --info AF_ESP\n</code></pre> <p><code>clinvar.parquet</code> will contain <code>id</code> of variant as well as all the info fields you've selected with the <code>info</code> option. If not set, all the info columns will end up in the output file.</p> <p>Options:</p> <ul> <li><code>-r|--rename-id</code>: Can be used to rename vcf id column name (default is <code>vid</code>).</li> <li><code>-i|--info</code>: Lets you select the info fields you wish to output. If not set, this will export them all.</li> <li><code>vcf</code>: If the input file type is VCF</li> </ul> <p>Tip</p> <p>Mind the <code>vcf</code> argument, as the following options depend on the input file type.</p>"},{"location":"#csv-or-tsv-format","title":"CSV or TSV format","text":"<pre><code>variantplaner annotations -i annotations.tsv -o annotations.parquet csv -c chr -p pos -r ref -a alt -s$'\\t' --info CLNDN --info AF_ESP\n</code></pre> <p>Unlike the VCF format, <code>variantplaner</code> has no way to tell which columns in the CSV/TSV file correspond to the relevant fields of a variant file. This is why you need to specify the column names in the options (requires a header).</p> <p>Options:</p> <ul> <li><code>-c|--chromosome</code>: Name of chromosome column</li> <li><code>-p|--position</code>: Name of position column</li> <li><code>-r|--reference</code>: Name of reference column</li> <li><code>-a|--alternative</code>: Name of alternative column</li> <li><code>-i|--info</code>: Lets you select the info fields you'd like to output. If not set, this will export them all.</li> <li><code>-s|--separator</code>: A single byte character to use as a delimiter in the input file (defaults to <code>,</code>)</li> </ul>"},{"location":"#metadata","title":"Metadata","text":""},{"location":"#json-format","title":"JSON format","text":"<pre><code>variantplaner metadata -i metadata.json -o metadata.parquet json -f sample -f link -f kindex\n</code></pre>"},{"location":"#csv-format","title":"Csv format","text":"<pre><code>variantplaner metadata -i metadata.csv -o metadata.parquet csv -c sample -c link -c kindex\n</code></pre>"},{"location":"#generate","title":"Generate","text":""},{"location":"#variants-transmission","title":"Variants transmission","text":"<p>If you study germline variants it's useful to calculate the familial origin of variants.</p> <pre><code>variantplaner generate transmission -i genotypes.parquet -I index_sample_name -m mother_sample_name -f father_sample_name -t transmission.parquet\n</code></pre> <p><code>genotypes.parquet</code> file with variants of all family. This file must contains <code>gt</code> and <code>samples</code> columns.</p> <p>In <code>transmission.parquet</code> each line contains an index sample variants, index, mother, father genotypes sample information and also column origin.</p> <p>Origin column contains a number with 3 digit: <pre><code>#~\"\n\u2502\u2502\u2514 father genotype\n\u2502\u2514\u2500 mother genotype\n\u2514\u2500\u2500 index genotype\n</code></pre></p> <p>You can also use pedigree file:</p> <pre><code>variantplaner generate transmission -i genotypes.parquet -p family.ped -t transmission.parquet\n</code></pre> Danger <p>This command could have important RAM usage (propotionaly to number of sample index variants)</p>"},{"location":"#contribution","title":"Contribution","text":"<p>All contributions are welcome, see our \"How to contribute\" page.</p>"},{"location":"benchmark/","title":"Benchmark","text":"<p>Figure showing the performance of some variantplaner functions to check their complexity or compare certain features.</p> <pre><code>Traceback (most recent call last):\n  File \"/home/runner/work/variantplaner/variantplaner/.venv/lib/python3.12/site-packages/markdown_exec/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/home/runner/work/variantplaner/variantplaner/.venv/lib/python3.12/site-packages/markdown_exec/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n1&gt;\", line 14, in &lt;module&gt;\n    import altair\nModuleNotFoundError: No module named 'altair'\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#031-2024-12-16","title":"0.3.1 - 2024-12-16","text":"<p>Compare with 0.3.1</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>struct unique variant split variants by chromosome (ae7eb65 by Pierre Marijon).</li> <li>struct genotype polars threads parameter have an effect (6419e02 by Pierre Marijon).</li> <li>use new functionality of variantplaner_rs in variantplaner cli (f986213 by Pierre Marijon).</li> <li>variantplaner_rs partitions could be parameterize (8b2066e by Pierre Marijon).</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>use number of bit ask by user in partitions (4409d8c by Pierre Marijon).</li> <li>readd documentation generation (6467ee2 by Pierre Marijon).</li> <li>transmission generation not failled if ped file contain only one line (58ee926 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#030-2024-09-30","title":"0.3.0 - 2024-09-30","text":"<p>Compare with 0.2.4</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>move ped code from io to object (b6638ca by Pierre Marijon).</li> <li>parquet2vcf can extract only variant of one chromosome (f29c6ac by Pierre Marijon).</li> <li>improve alt '*' management (755a5fa by Pierre Marijon).</li> <li>partition support append mode (1b6603f by Pierre Marijon).</li> <li>variant merge support append (d12d357 by Pierre Marijon).</li> <li>Add python 3.12 in ci test and support (c51c932 by Pierre Marijon).</li> <li>Better variant hash we only need store ref length (8a3db5e by Pierre Marijon).</li> <li>add documentation on how interogate genotype variants partitions (b843bca by Pierre Marijon).</li> <li>New cli (c2cb033 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>add output file in struct operation only if it's exist (9a868ad by Pierre Marijon).</li> <li>not failled if SVTYPE or SVLEN column isn't present (32a8dad by Pierre Marijon).</li> <li>correct benchmark script run (8ebdca0 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Move many variant operation in object. (df36fa0 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#024-2023-12-21","title":"0.2.4 - 2023-12-21","text":"<p>Compare with 0.2.4</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>add variantplaner logo.</li> <li>add method to compute partition value of id.</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>fix: #41 vcf spec indicate Integer must be store in 32bits.</li> <li>update to polars 0.20.</li> </ul>"},{"location":"changelog/#023-2023-11-21","title":"0.2.3 - 2023-11-21","text":"<p>Compare with 0.2.2</p>"},{"location":"changelog/#features_3","title":"Features:","text":"<ul> <li>Use ruff format in place of black</li> <li>Minimal polars version is 0.19.15</li> <li>SV cannot have small variant id</li> <li>Type of id is include in part of id (all long variant are store in same place)</li> </ul>"},{"location":"changelog/#fix","title":"Fix:","text":"<ul> <li>Usage intgerate chromosome2length option</li> </ul>"},{"location":"changelog/#022-2023-10-19","title":"0.2.2 - 2023-10-19","text":"<p>Compare with first 0.2.0</p>"},{"location":"changelog/#fix_1","title":"Fix:","text":"<ul> <li>Correct typo in readme</li> <li>Correct change in variantplaner_rs/Cargo.lock</li> </ul>"},{"location":"changelog/#021-2023-10-09","title":"0.2.1 - 2023-10-09","text":"<p>Compare with first 0.2.0</p>"},{"location":"changelog/#fix_2","title":"Fix:","text":"<ul> <li>Hot fix some lazy trouble</li> </ul>"},{"location":"changelog/#020-2023-10-02","title":"0.2.0 - 2023-10-02","text":"<p>Compare with first 0.1.0</p>"},{"location":"changelog/#features_4","title":"Features:","text":"<ul> <li>Replace hash variant id by a uniq variant id</li> <li>Improve variant transmission system to support genome with ploidie lower than 92</li> <li>Genotype partitioning now use position part of unique id to get more local request</li> </ul>"},{"location":"changelog/#fixes","title":"Fixes:","text":"<ul> <li>Documentation fix</li> <li>Test coverage improvement</li> </ul>"},{"location":"changelog/#010-2023-07-25","title":"0.1.0 - 2023-07-25","text":"<p>Compare with first commit</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pierre.marijon-ext@aphp.fr. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Note</p> <p> Usage of pyenv is recommended</p> <p>After install pyenv run: <pre><code>pyenv install 3.9 3.10 3.11\n</code></pre></p> <p>Fork and clone the repository, then:</p> <pre><code>cd variantplaner\nmake setup\n</code></pre> <p>Note</p> <p> If it fails for some reason, you'll need to install PDM manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install uv\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>uv sync</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>uv run variantplaner [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>The entry-point to run commands and tasks is the <code>make</code> Python script, located in the <code>scripts</code> directory. Try running <code>make</code> to show the available commands and tasks. The commands do not need the Python dependencies to be installed, while the tasks do. The cross-platform tasks are written in Python, thanks to duty.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":"<pre><code>    # Credits\n\n    These projects were used to build *variantplaner*. **Thank you!**\n\n    [Python](https://www.python.org/) |\n    [uv](https://github.com/astral-sh/uv) |\n    [copier-uv](https://github.com/pawamoy/copier-uv)\n\n    {% macro dep_line(dep) -%}\n    [{{ dep.name }}](https://pypi.org/project/{{ dep.name }}/) | {{ dep.summary }} | {{ (\"`\" ~ dep.spec|sort(reverse=True)|join(\", \") ~ \"`\") if dep.spec else \"\" }} | `{{ dep.version }}` | {{ dep.license }}\n    {%- endmacro %}\n\n    {% if prod_dependencies -%}\n    ### Runtime dependencies\n\n    Project | Summary | Version (accepted) | Version (last resolved) | License\n    ------- | ------- | ------------------ | ----------------------- | -------\n    {% for dep in prod_dependencies -%}\n    {{ dep_line(dep) }}\n    {% endfor %}\n\n    {% endif -%}\n    {% if dev_dependencies -%}\n    ### Development dependencies\n\n    Project | Summary | Version (accepted) | Version (last resolved) | License\n    ------- | ------- | ------------------ | ----------------------- | -------\n    {% for dep in dev_dependencies -%}\n    {{ dep_line(dep) }}\n    {% endfor %}\n\n    {% endif -%}\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2024 Pierre Marijon\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"usage/","title":"VariantPlaner","text":"<p>variantplaner is a set of tools that converts a large set of vcf's into an interoperable data structure efficiently.</p> <p>To show the capabilities of the <code>variantplaner</code>, we will use a small example.</p> <p>The purpose of this short tutorial is to present:</p> <ul> <li>how to convert vcf into a more suitable format</li> <li>how data can be restructured for querying</li> <li>how to integrate variant annotation databases</li> <li>how these different files can be used to obtain interesting biological information</li> </ul> <p>This tutorial suggests an organization of files, but you're under no obligation to follow it <code>variantplaner</code> is quite flexible in its organization.</p>"},{"location":"usage/#setup","title":"Setup","text":"<p>This tutorial assume you are on unix like system, you have python setup and you install variantplaner</p> <p>Requirements list:</p> <ul> <li>curl</li> <li>gunzip</li> <li>pqrs (only for transmission computation, otherwise optional)</li> </ul> <p>Optional:</p> <ul> <li>gnu-parallel</li> </ul> <p>Quering dataset:</p> <ul> <li>polars-cli</li> <li>duckdb</li> </ul>"},{"location":"usage/#download-data","title":"Download data","text":"<pre><code>mkdir -p vp_tuto/vcf/\ncd vp_tuto\nURI_ROOT=\"https://ftp-trace.ncbi.nlm.nih.gov/ReferenceSamples/giab/release\"\ncurl ${URI_ROOT}/NA12878_HG001/latest/GRCh38/HG001_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG001.vcf\ncurl ${URI_ROOT}/AshkenazimTrio/HG002_NA24385_son/latest/GRCh38/HG002_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG002.vcf\ncurl ${URI_ROOT}/AshkenazimTrio/HG003_NA24149_father/latest/GRCh38/HG003_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG003.vcf\ncurl ${URI_ROOT}/AshkenazimTrio/HG004_NA24143_mother/latest/GRCh38/HG004_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG004.vcf\ncurl ${URI_ROOT}/ChineseTrio/HG006_NA24694_father/latest/GRCh38/HG006_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG006.vcf\ncurl ${URI_ROOT}/ChineseTrio/HG007_NA24695_mother/latest/GRCh38/HG007_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG007.vcf\n</code></pre>"},{"location":"usage/#variant-planner-presentation","title":"Variant planner presentation","text":"<p>variantplaner is a python module with command line tools, it is composed of several subcommands (they will be detailed later) but has two global options, one for parallelization and another for the level of verbosity you want.</p> <pre><code>Usage: variantplaner [OPTIONS] COMMAND [ARGS]...\n\n  Run VariantPlanner.\n\nOptions:\n  -t, --threads INTEGER RANGE  Number of threads usable  [default: 1; x&gt;=0]\n  -v, --verbose                Verbosity level  [0&lt;=x&lt;=4]\n  --debug-info                 Get debug information\n  -h, --help                   Show this message and exit.\n\nCommands:\n  metadata      Convert metadata file in parquet file.\n  parquet2vcf   Convert variant parquet in vcf.\n  struct        Subcommand to made struct operation on parquet file.\n  transmission  Generate transmission of a genotype set.\n  vcf2parquet   Convert a vcf in parquet.\n</code></pre>"},{"location":"usage/#vcf2parquet","title":"vcf2parquet","text":"<p>First step is to convert vcf data in parquet, it's a column oriented format with better performance than indexed vcf.</p> <p>We split vcf in two part on for variant information and another for genotype information.</p> <pre><code>mkdir -p variants genotypes/samples/\n</code></pre> <pre><code>for vcf_path in $(ls vcf/*.vcf)\ndo\n    sample_name=$(basename ${vcf_path} .vcf)\n    variantplaner -t 4 vcf2parquet -i ${vcf_path} \\\n    -c grch38.92.csv \\\n    variants -o variants/${sample_name}.parquet \\\n    genotypes -o genotypes/samples/${sample_name}.parquet \\\n    -f GT:PS:DP:ADALL:AD:GQ\ndone\n</code></pre> <p>We iterate over all vcf, variants are store in <code>variants/{sample_name}.parquet</code>, genotype information are store in <code>variants/{sample_name}.parquet</code>. Only genotypes with a format value equal to the <code>-f</code> parameter value are retained.</p> gnu-parallel method <pre><code>find vcf -type f -name *.vcf -exec basename {} .vcf \\; | \\\nparallel variantplaner -t 2 vcf2parquet -c grch38.92.csv -i vcf/{}.vcf \\\nvariants -o variants/{}.parquet genotypes -o genotypes/samples/{}.parquet -f GT:PS:DP:ADALL:AD:GQ\n</code></pre> <p>Parquet variants file contains 5 column:</p> <ul> <li>pos: Position of variant</li> <li>ref: Reference sequence</li> <li>alt: Alternative sequence</li> <li>id: An hash of other value collision isn't check but highly improbable check api documentation</li> </ul> variants parquet file content <p>You can inspect content of parquet file generate with pqrs <pre><code>pqrs head variants/HG001.parquet\n{id: 17886044532216650390, chr: 1, pos: 783006, ref: \"A\", alt: \"G\"}\n{id: 7513336577790240873, chr: 1, pos: 783175, ref: \"T\", alt: \"C\"}\n{id: 17987040642944149052, chr: 1, pos: 784860, ref: \"T\", alt: \"C\"}\n{id: 10342734968077036194, chr: 1, pos: 785417, ref: \"G\", alt: \"A\"}\n{id: 890514037559296207, chr: 1, pos: 797392, ref: \"G\", alt: \"A\"}\n</code></pre></p> <p>Parquet genotypes file contains column:</p> <ul> <li>id: Same as variant id</li> <li>gt: vcf GT value 1 -&gt; heterozygote 2 -&gt; homozygote (phasing information is lost)</li> <li>ps: Phase set in which this variant falls</li> <li>dp: vcf DP coverage of the variant for this sample</li> <li>adall: Net allele depths across all datasets</li> <li>ad: vcf AD per allele reads depth</li> <li>gq: vcf GQ quality of variant for this sample</li> </ul> genotypes parquet file content <p>You can inspect content of parquet file generate with pqrs <pre><code>pqrs head genotypes/samples/HG001.parquet\n{id: 17886044532216650390, sample: \"HG001\", gt: 2, ps: null, dp: 652, adall: [16, 234], ad: [0, 82], gq: 312}\n{id: 7513336577790240873, sample: \"HG001\", gt: 2, ps: null, dp: 639, adall: [0, 218], ad: [0, 84], gq: 194}\n{id: 17987040642944149052, sample: \"HG001\", gt: 2, ps: null, dp: 901, adall: [105, 406], ad: [0, 74], gq: 301}\n{id: 10342734968077036194, sample: \"HG001\", gt: 2, ps: null, dp: 820, adall: [125, 383], ad: [0, 70], gq: 339}\n{id: 890514037559296207, sample: \"HG001\", gt: 1, ps: null, dp: 760, adall: [161, 142], ad: [25, 37], gq: 147}\n</code></pre></p>"},{"location":"usage/#structuration-of-data","title":"Structuration of data","text":""},{"location":"usage/#merge-all-variant","title":"Merge all variant","text":"<p>We can now aggregate all variant present in our dataset to perform this operation we use divide to conquer merge method by generate temporary file. By default, file are written in <code>/tmp</code> but you can control where these files are written by set <code>TMPDIR</code>, <code>TEMP</code> or <code>TMP</code> directory.</p> <pre><code>variantplaner -t 8 struct -i variants/*.parquet -- variants -o variants.parquet\n</code></pre> <p>File <code>variants.parquet</code> contains all unique variants present in dataset, <code>--</code> after last input path are mandatory.</p>"},{"location":"usage/#genotypes-structuration","title":"Genotypes structuration","text":""},{"location":"usage/#by-samples","title":"By samples","text":"<p>This structurations data is already down in vcf2parquet step check content of <code>genotypes/samples</code>: <pre><code>\u279c ls genotypes/samples\nHG001.parquet  HG002.parquet  HG003.parquet  HG004.parquet  HG006.parquet  HG007.parquet\n</code></pre></p>"},{"location":"usage/#by-variants","title":"By variants","text":"<p>Here, we'll organize the genotypes information by variants to make it easier to find samples where a variant is present or not.</p> <pre><code>mkdir -p genotypes/variants/\nvariantplaner -t 8 struct -i genotypes/samples/*.parquet -- genotypes -p genotypes/variants\n</code></pre> <p>All genotypes information are split in hive like structure to optimize request on data.</p>"},{"location":"usage/#compute-transmission-mode","title":"Compute transmission mode","text":"<p>If you are working with families, <code>variantplaner</code> can calculate the modes of transmission of the variants.</p> <p>For these step, we need to concatenate all genotypes of a AshkenazimTrio in one parquet sample.</p> <pre><code>pqrs merge -i genotypes/samples/HG002.parquet genotypes/samples/HG003.parquet genotypes/samples/HG004.parquet -o genotypes/samples/AshkenazimTrio.parquet\nmkdir -p genotypes/transmissions/\nvariantplaner transmission -g genotypes/samples/AshkenazimTrio.parquet -i HG002 -m HG003 -f HG004 -o genotypes/transmissions/AshkenazimTrio.parquet\n</code></pre> <p><code>-I</code> parameter is use for index sample, <code>-m</code> parameter is use for mother sample, <code>-f</code> parameter is use for father sample only the index sample is mandatory if mother sample or father sample isn't present command work, you could also use a pedigree file with parameter <code>-p</code>.</p> transmission parquet file content <pre><code>{id: 10201716324449815219, index_gt: 2, index_ps: null, index_dp: 1066, index_adall: [0, 284], index_ad: [118, 586], index_gq: 598, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"#~~\"}\n{id: 8292180701257594706, index_gt: 1, index_ps: null, index_dp: 1122, index_adall: [177, 165], index_ad: [310, 283], index_gq: 556, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n{id: 1728452411043401356, index_gt: 1, index_ps: null, index_dp: 1365, index_adall: [225, 222], index_ad: [348, 380], index_gq: 658, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n{id: 4237549706021671868, index_gt: 1, index_ps: null, index_dp: 1019, index_adall: [154, 153], index_ad: [277, 282], index_gq: 517, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n{id: 1361753917441299167, index_gt: 1, index_ps: null, index_dp: 1033, index_adall: [159, 170], index_ad: [265, 273], index_gq: 552, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n</code></pre> <p>Parquet transmissions file contains column all genotypes information with suffix <code>_index</code>, <code>_mother</code> and <code>_father</code> plus a <code>origin</code> column</p> <p>Origin column contains a string with 3 character:</p> <pre><code>#~\"\n\u2502\u2502\u2514 ASCII_value_of(father genotype + 33)\n\u2502\u2514\u2500 ASCII_value_of(mother genotype + 33)\n\u2514\u2500\u2500 ASCII_value_of(index genotype  + 33)\n</code></pre> <p>In this example case, variants is homozygotes in index, mother information is missing, variants is heterozygotes in father.</p> <p>Maximal genotype value is 92, which corresponds to the character <code>}</code>, <code>~</code> match with value 93, this value also mean unknow genotype.</p>"},{"location":"usage/#add-annotations","title":"Add annotations","text":"<p>To work on your variant, you probably need variants annotations.</p>"},{"location":"usage/#snpeff-annotations","title":"Snpeff annotations","text":"<p>First convert your unique variants in parquet format (<code>variants.parquet</code>) in vcf: <pre><code>variantplaner -t 8 parquet2vcf -i variants.parquet -o variants.vcf\n</code></pre></p> <p><code>parquet2vcf</code> subcommand have many more options but we didn't need it now.</p> <p>Next annotate this <code>variants.vcf</code> with snpeff, we assume you generate a file call <code>variants.snpeff.vcf</code>.</p> <p>To convert annotated vcf in parquet, keep 'ANN' info column and rename vcf id column in snpeff_id you can run: <pre><code>mkdir -p annotations\nvariantplaner -t 8 vcf2parquet -c grch38.92.csv -i variants.snpeff.vcf annotations -o annotations/snpeff.parquet vcf -i ANN -r snpeff_id\n</code></pre></p> <p>If you didn't set any value of option <code>-i</code> in vcf subsubcommand all info column are keep.</p>"},{"location":"usage/#clinvar-annotations","title":"Clinvar annotations","text":"<p>Download last clinvar version:</p> <pre><code>mkdir -p annotations\ncurl https://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh38/clinvar.vcf.gz \\\n| gunzip - &gt; annotations/clinvar.vcf\n</code></pre> <p>Because clinvar's vcf file header does not contain information on contigs, you should create file <code>grch38.92.csv</code> with this content: <pre><code>contig,length\nchr1,248956422\nchr10,133797422\nchr11,135086622\nchr12,133275309\nchr13,114364328\nchr14,107043718\nchr15,101991189\nchr16,90338345\nchr17,83257441\nchr18,80373285\nchr19,58617616\nchr2,242193529\nchr20,64444167\nchr21,46709983\nchr22,50818468\nchr3,198295559\nchr4,190214555\nchr5,181538259\nchr6,170805979\nchr7,159345973\nchr8,145138636\nchr9,138394717\nchrMT,16569\nchrX,156040895\nchrY,57227415\n</code></pre></p> <p>Convert clinvar vcf file in parquet file:</p> <pre><code>variantplaner vcf2parquet -c grch38.92.csv -i annotations/clinvar.vcf annotations -o annotations/clinvar.parquet -r clinvar_id\n</code></pre> <p>Parquet file produce contains many columns:</p> <ul> <li>clinvar_id: content of vcf id column if option <code>-r</code> is not set, column name is <code>vid</code></li> <li>id: variantplaner id</li> <li>All INFO filed</li> </ul> <p>Annotations subcommand try to make match between vcf info type and parquet type.</p> <code>annotations/clinvar.parquet</code> file content <pre><code>pqrs head annotations/clinvar.parquet\n{clinvar_id: 2205837, id: 11650605831284591550, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2193183, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69134A&gt;G\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Likely_benign\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2252161, id: 2295086632353399847, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2238986, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69581C&gt;G\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2396347, id: 11033100074712141168, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2386655, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69682G&gt;A\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2288999, id: 10487392163259126218, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2278803, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69769T&gt;C\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2351346, id: 5356120651941363990, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2333177, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69995G&gt;C\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n</code></pre> <p>With option of subcommand vcf <code>-i</code> you can select which column are included in parquet file For example command: <pre><code>variantplaner vcf2parquet -c grch38.92.csv -i annotations/clinvar.vcf annotations -o annotations/clinvar.parquet -r clinvar_id -i ALLELEID -i CLNDN -i AF_ESP -i GENEINFO\n</code></pre></p> <p>Produce a <code>annotations/clinvar.parquet</code> with columns:</p> <ul> <li>clinvar_id</li> <li>id</li> <li>ALLELEID</li> <li>CLNDN</li> </ul> <code>annotations/clinvar.parquet</code> file content <pre><code>\u279c pqrs head annotations/clinvar.parquet\n{clinvar_id: 2205837, id: 11650605831284591550, ALLELEID: 2193183, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2252161, id: 2295086632353399847, ALLELEID: 2238986, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2396347, id: 11033100074712141168, ALLELEID: 2386655, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2288999, id: 10487392163259126218, ALLELEID: 2278803, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2351346, id: 5356120651941363990, ALLELEID: 2333177, CLNDN: [\"Inborn_genetic_diseases\"]}\n</code></pre>"},{"location":"usage/#split-snpeff-annotations-in-parquet-column","title":"Split snpeff annotations in parquet column","text":"<p>After annotate your vcf with snpeff in <code>ann</code> mode and write result in file <code>snpeff_annotations.vcf</code> you could run a script similar to this to generate <code>snpeff_annotations.parquet</code>: <pre><code>from variantplaner import Vcf\n\nvcf = Vcf()\ntry:\n    vcf.from_path(\"snpeff_annotations.vcf\", \"grch38.92.csv\")\nexcept variantplaner.exception.NotAVCFError:\n    print(\"snpeff_annotations.vcf seems to have error\")\n    return 1\nexcept variantplaner.exception.NoContigsLengthInformationError:\n    print(\"snpeff_annotations.vcf header seems not contain contig information\")\n    return 2\n\nlf = vcf.lf.with_columns(vcf.header.info_parser())\nlf = lf.drop([\"chr\", \"pos\", \"ref\", \"alt\", \"filter\", \"qual\", \"info\"])\nlf = lf.rename({\"vid\": \"id\"})\n\nlf = lf.with_columns(\n    [\n        polars.col(\"ANN\")\n        .list.get(0)\n        .str.split(\"|\")\n        .cast(polars.List(polars.Utf8()))\n        .alias(\"ann\"),\n    ]\n).drop(\"ANN\")\n\nlf = lf.with_columns(\n    [\n        polars.col(\"ann\").list.get(1).alias(\"effect\"),\n        polars.col(\"ann\").list.get(2).alias(\"impact\"),\n        polars.col(\"ann\").list.get(3).alias(\"gene\"),\n        polars.col(\"ann\").list.get(4).alias(\"geneid\"),\n        polars.col(\"ann\").list.get(5).alias(\"feature\"),\n        polars.col(\"ann\").list.get(6).alias(\"feature_id\"),\n        polars.col(\"ann\").list.get(7).alias(\"bio_type\"),\n        polars.col(\"ann\").list.get(8).alias(\"rank\"),\n        polars.col(\"ann\").list.get(9).alias(\"hgvs_c\"),\n        polars.col(\"ann\").list.get(10).alias(\"hgvs_p\"),\n        polars.col(\"ann\").list.get(11).alias(\"cdna_pos\"),\n        polars.col(\"ann\").list.get(12).alias(\"cdna_len\"),\n        polars.col(\"ann\").list.get(13).alias(\"cds_pos\"),\n        polars.col(\"ann\").list.get(14).alias(\"cvs_len\"),\n        polars.col(\"ann\").list.get(15).alias(\"aa_pos\"),\n    ]\n).drop(\"ann\")\n\nlf.sink_parquet(\"snpeff_annotations.parquet\")\n</code></pre></p>"},{"location":"usage/#querying","title":"Querying","text":"<p>You can use any tool or software library supporting the parquet format to use the files generated by <code>variantplaner</code>.</p> <p>We show you how to use files with polars-cli and duckdb.</p>"},{"location":"usage/#polars-cli","title":"polars-cli","text":""},{"location":"usage/#count-variants","title":"Count variants","text":"<pre><code>\u3009select count(*) from read_parquet('variants.parquet');\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 count   \u2502\n\u2502 ---     \u2502\n\u2502 u32     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 7852699 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> check result with <code>pqrs</code> <p>We can check we have same result with pqrs</p> <pre><code>\u279c pqrs rowcount variants.parquet\nFile Name: variants.parquet: 7852699 rows\n</code></pre>"},{"location":"usage/#filter-variants-from-annotations","title":"Filter variants from annotations:","text":"<p>Get all variant with a AF_ESP upper than 0.9999</p> <pre><code>\u3009select chr, pos, ref, alt, AF_ESP from read_parquet('variants.parquet') as v left join read_parquet('annotations/clinvar.parquet') as c on c.id=v.id where AF_ESP&gt;0.9999;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 chr \u2506 pos      \u2506 ref \u2506 alt \u2506 AF_ESP  \u2502\n\u2502 --- \u2506 ---      \u2506 --- \u2506 --- \u2506 ---     \u2502\n\u2502 u8  \u2506 u64      \u2506 str \u2506 str \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10  \u2506 16901372 \u2506 G   \u2506 C   \u2506 0.99992 \u2502\n\u2502 11  \u2506 78121030 \u2506 T   \u2506 A   \u2506 0.99992 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#get-sample-have-variant","title":"Get sample have variant","text":"<p>Get all variant and sample with GENEINFO equal to 'SAMD11:148398'</p> <pre><code>\u3009select distinct chr, pos, ref, alt, sample from read_parquet('variants.parquet') as v left join read_parquet('genotypes/samples/*') as g on v.id=g.id left join read_parquet('annotations/clinvar.parquet') as a on v.id=a.id WHERE GENEINFO='SAMD11:148398';\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 chr \u2506 pos    \u2506 ref \u2506 alt \u2506 sample \u2502\n\u2502 --- \u2506 ---    \u2506 --- \u2506 --- \u2506 ---    \u2502\n\u2502 u8  \u2506 u64    \u2506 str \u2506 str \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG003  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG001  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG007  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG004  \u2502\n\u2502 \u2026   \u2506 \u2026      \u2506 \u2026   \u2506 \u2026   \u2506 \u2026      \u2502\n\u2502 1   \u2506 942934 \u2506 G   \u2506 C   \u2506 HG003  \u2502\n\u2502 1   \u2506 943937 \u2506 C   \u2506 T   \u2506 HG004  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG002  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG006  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#duckdb","title":"duckdb","text":""},{"location":"usage/#count-variants_1","title":"Count variants","text":"<pre><code>D select count(*) from read_parquet('variants.parquet');\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 count_star() \u2502\n\u2502    int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      7852699 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> check result with <code>pqrs</code> <p>We can check we have same result with pqrs</p> <pre><code>\u279c pqrs rowcount variants.parquet\nFile Name: variants.parquet: 7852699 rows\n</code></pre>"},{"location":"usage/#filter-variants-from-annotations_1","title":"Filter variants from annotations:","text":"<p>Get all variant with a AF_ESP upper than 0.9999</p> <pre><code>D select chr, pos, ref, alt, AF_ESP from read_parquet('variants.parquet') as v left join read_parquet('annotations/clinvar.parquet') as c on c.id=v.id where AF_ESP&gt;0.9999;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  chr  \u2502   pos    \u2502   ref   \u2502   alt   \u2502 AF_ESP  \u2502\n\u2502 uint8 \u2502  uint64  \u2502 varchar \u2502 varchar \u2502 double  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    10 \u2502 16901372 \u2502 G       \u2502 C       \u2502 0.99992 \u2502\n\u2502    11 \u2502 78121030 \u2502 T       \u2502 A       \u2502 0.99992 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#get-sample-have-variant_1","title":"Get sample have variant","text":"<p>Get all variant and sample with GENEINFO equal to 'SAMD11:148398'</p> <pre><code>D select distinct chr, pos, ref, alt, sample from read_parquet('variants.parquet') as v left join read_parquet('genotypes/samples/*') as g on v.id=g.id left join read_parquet('annotations/clinvar.parquet') as a on v.id=a.id WHERE GENEINFO='SAMD11:148398';\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  chr  \u2502  pos   \u2502   ref   \u2502   alt   \u2502 sample  \u2502\n\u2502 uint8 \u2502 uint64 \u2502 varchar \u2502 varchar \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG002   \u2502\n\u2502     1 \u2502 942934 \u2502 G       \u2502 C       \u2502 HG002   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG003   \u2502\n\u2502     1 \u2502 942934 \u2502 G       \u2502 C       \u2502 HG003   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG007   \u2502\n\u2502     1 \u2502 943937 \u2502 C       \u2502 T       \u2502 HG007   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG001   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG004   \u2502\n\u2502     1 \u2502 943937 \u2502 C       \u2502 T       \u2502 HG004   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG006   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 10 rows                            5 columns \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#use-genotype-partition","title":"Use genotype partition","text":"<p>In this example, I'll show how I interact with the data structures created by variantplaner.</p>"},{"location":"usage/#import","title":"Import","text":"<pre><code>import duckdb\nimport polars\nimport variantplaner\n</code></pre>"},{"location":"usage/#get-variants","title":"Get variants","text":"<pre><code>query = f\"\"\"\nSELECT\n  *\nFROM\n  read_parquet('variants.parquet') as v\nWHERE\n  v.chr == '19'\n\"\"\"\n\nvariants = duckdb.query(query).pl()\n</code></pre>"},{"location":"usage/#add-annotations_1","title":"Add annotations","text":"<pre><code>query = f\"\"\"\nSELECT\n  v.*, c.CLNSIG\nFROM\n  variants as v\n  JOIN\n  read_parquet('annotations/clinvar.parquet') as c\n  ON\n  v.id == c.id\nWHERE\n  c.CLNSIG LIKE '%Patho%'\n\"\"\"\n\nannotations = duckdb.query(query).pl()\n</code></pre>"},{"location":"usage/#add-genotypes","title":"Add genotypes","text":"<pre><code>def worker(name_data: (str, polars.DataFrame)) -&gt; polars.DataFrame:\n    \"\"\"Request genotype homozygote variant.\"\"\"\n    name, data = name_data\n    query = f\"\"\"\nSELECT\n  data.*, g.*,\nFROM\n  data\n  JOIN\n  read_parquet('genotypes/variants/id_part={name}/0.parquet') as g ON data.id = g.id\nWHERE\n  g.gt == 2\n\"\"\"\n    df = duckdb.query(query).pl()\n    return df\n\n\nannotations = variantplaner.normalization.add_id_part(annotations)\n\nall_genotypes = []\n\nfor data in map(worker, annotations.group_by(by=\"id_part\")):\n    if data is not None:\n        all_genotypes.append(data)\n\ngenotypes = polars.concat(all_genotypes)\n</code></pre> <p>genotypes is polars.DataFrame with pathogene homozygote variants in chromosome 19.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> variantplaner<ul> <li> cli<ul> <li> metadata</li> <li> parquet2vcf</li> <li> struct</li> <li> transmission</li> <li> vcf2parquet</li> </ul> </li> <li> debug</li> <li> exception</li> <li> extract</li> <li> generate</li> <li> io<ul> <li> vcf</li> </ul> </li> <li> normalization</li> <li> objects<ul> <li> annotations</li> <li> contigs_length</li> <li> csv</li> <li> genotypes</li> <li> pedigree</li> <li> variants</li> <li> vcf</li> <li> vcf_header</li> </ul> </li> <li> struct<ul> <li> genotypes</li> <li> variants</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/variantplaner/","title":"Index","text":""},{"location":"reference/variantplaner/#variantplaner","title":"variantplaner","text":"<p>VariantPlaner, a tool kit to manage many variants without many cpu and ram resource.</p> <p>Convert a vcf in parquet, convert annotations in parquet, convert parquet in vcf.</p> <p>But also build a file struct to get a fast variant database interrogations time.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Module contains command line entry point function.</p> </li> <li> <code>debug</code>           \u2013            <p>Debugging utilities.</p> </li> <li> <code>exception</code>           \u2013            <p>Exception could be generate by VariantPlanner.</p> </li> <li> <code>extract</code>           \u2013            <p>Extract information of polars.LazyFrame produce from raw vcf file parsing.</p> </li> <li> <code>generate</code>           \u2013            <p>Function to generate information.</p> </li> <li> <code>io</code>           \u2013            <p>Module manage input parsing and output serializing.</p> </li> <li> <code>normalization</code>           \u2013            <p>Function use to normalize data.</p> </li> <li> <code>objects</code>           \u2013            <p>Module to store variantplaner object.</p> </li> <li> <code>struct</code>           \u2013            <p>Generated data structures for easy integration.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Annotations</code>           \u2013            <p>Object to manage lazyframe as Annotations.</p> </li> <li> <code>ContigsLength</code>           \u2013            <p>Store contigs -&gt; length information.</p> </li> <li> <code>Genotypes</code>           \u2013            <p>Object to manage lazyframe as Genotypes.</p> </li> <li> <code>Pedigree</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> <li> <code>Variants</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> <li> <code>Vcf</code>           \u2013            <p>Object to manage lazyframe as Vcf.</p> </li> <li> <code>VcfHeader</code>           \u2013            <p>Object that parse and store vcf information.</p> </li> <li> <code>VcfParsingBehavior</code>           \u2013            <p>Enumeration use to control behavior of IntoLazyFrame.</p> </li> </ul>"},{"location":"reference/variantplaner/#variantplaner.Annotations","title":"Annotations","text":"<pre><code>Annotations()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Annotations.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Annotations object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Annotations.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Annotations.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n    }\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.ContigsLength","title":"ContigsLength","text":"<pre><code>ContigsLength()\n</code></pre> <p>Store contigs -&gt; length information.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Fill object with file point by pathlib.Path.</p> </li> <li> <code>from_vcf_header</code>             \u2013              <p>Fill a object with VcfHeader.</p> </li> </ul> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise a contigs length.\"\"\"\n    self.lf = polars.LazyFrame(\n        schema={\n            \"contig\": polars.String,\n            \"length\": polars.UInt64,\n            \"offset\": polars.UInt64,\n        }\n    )\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.ContigsLength.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path, /, **scan_csv_args: Unpack[ScanCsv]\n) -&gt; int\n</code></pre> <p>Fill object with file point by pathlib.Path.</p> <p>Argument: path: path of input file</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_path(self, path: pathlib.Path, /, **scan_csv_args: Unpack[ScanCsv]) -&gt; int:\n    \"\"\"Fill object with file point by pathlib.Path.\n\n    Argument:\n    path: path of input file\n\n    Returns: Number of contigs line view\n    \"\"\"\n    csv = Csv()\n    csv.from_path(path, **scan_csv_args)\n    self.lf = csv.lf\n\n    self.__compute_offset()\n\n    return self.lf.collect().shape[0]\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.ContigsLength.from_vcf_header","title":"from_vcf_header","text":"<pre><code>from_vcf_header(header: VcfHeader) -&gt; int\n</code></pre> <p>Fill a object with VcfHeader.</p> Argument <p>header: VcfHeader</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_vcf_header(self, header: VcfHeader) -&gt; int:\n    \"\"\"Fill a object with VcfHeader.\n\n    Argument:\n       header: VcfHeader\n\n    Returns: Number of contigs line view\n    \"\"\"\n    contigs_id = re.compile(r\"ID=(?P&lt;id&gt;[^,]+)\")\n    contigs_len = re.compile(r\"length=(?P&lt;length&gt;[^,&gt;]+)\")\n\n    count = 0\n    contigs2len: dict[str, list] = {\"contig\": [], \"length\": []}\n    for contig_line in header.contigs:\n        if (len_match := contigs_len.search(contig_line)) and (id_match := contigs_id.search(contig_line)):\n            contigs2len[\"contig\"].append(id_match.groupdict()[\"id\"])\n            contigs2len[\"length\"].append(int(len_match.groupdict()[\"length\"]))\n        count += 1\n\n    self.lf = polars.LazyFrame(contigs2len, schema={\"contig\": polars.String, \"length\": polars.UInt64})\n\n    self.__compute_offset()\n\n    return count\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Genotypes","title":"Genotypes","text":"<pre><code>Genotypes(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Genotypes.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> <li> <code>samples_names</code>             \u2013              <p>Get list of sample name.</p> </li> </ul> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Genotypes object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Genotypes.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Genotypes.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"sample\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Genotypes.samples_names","title":"samples_names","text":"<pre><code>samples_names() -&gt; list[str]\n</code></pre> <p>Get list of sample name.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def samples_names(self) -&gt; list[str]:\n    \"\"\"Get list of sample name.\"\"\"\n    return self.lf.select(\"sample\").collect().get_column(\"sample\").to_list()\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Pedigree","title":"Pedigree","text":"<pre><code>Pedigree()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Read a pedigree file in polars.LazyFrame.</p> </li> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> <li> <code>to_path</code>             \u2013              <p>Write pedigree polars.LazyFrame in ped format.</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Variants object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Pedigree.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Pedigree.from_path","title":"from_path","text":"<pre><code>from_path(input_path: Path) -&gt; None\n</code></pre> <p>Read a pedigree file in polars.LazyFrame.</p> <p>Parameters:</p> <ul> <li> <code>input_path</code>               (<code>Path</code>)           \u2013            <p>Path to pedigree file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>A polars.LazyFrame that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def from_path(self, input_path: pathlib.Path) -&gt; None:\n    \"\"\"Read a pedigree file in [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html).\n\n    Args:\n        input_path: Path to pedigree file.\n\n    Returns:\n        A [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')\n    \"\"\"\n    self.lf = polars.scan_csv(\n        input_path,\n        separator=\"\\t\",\n        has_header=False,\n        null_values=[\"None\", \"unknown\"],\n        new_columns=[\n            \"family_id\",\n            \"personal_id\",\n            \"father_id\",\n            \"mother_id\",\n            \"sex\",\n            \"affected\",\n        ],\n        schema_overrides=Pedigree.minimal_schema(),\n    )\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Pedigree.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"family_id\": polars.String,\n        \"personal_id\": polars.String,\n        \"father_id\": polars.String,\n        \"mother_id\": polars.String,\n        \"sex\": polars.String,\n        \"affected\": polars.Boolean,\n    }\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Pedigree.to_path","title":"to_path","text":"<pre><code>to_path(output_path: Path) -&gt; None\n</code></pre> <p>Write pedigree polars.LazyFrame in ped format.</p> <p>Warning: This function performs polars.LazyFrame.collect before write csv, this can have a significant impact on memory usage</p> <p>Parameters:</p> <ul> <li> <code>lf</code>           \u2013            <p>LazyFrame contains pedigree information.</p> </li> <li> <code>output_path</code>               (<code>Path</code>)           \u2013            <p>Path where write pedigree information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def to_path(self, output_path: pathlib.Path) -&gt; None:\n    \"\"\"Write pedigree [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) in ped format.\n\n    Warning: This function performs [polars.LazyFrame.collect][] before write csv, this can have a significant impact on memory usage\n\n    Args:\n        lf: LazyFrame contains pedigree information.\n        output_path: Path where write pedigree information.\n\n    Returns:\n        None\n    \"\"\"\n    self.lf.collect().write_csv(output_path, include_header=False, separator=\"\\t\")\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Variants","title":"Variants","text":"<pre><code>Variants(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Variants object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Variants.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf","title":"Vcf","text":"<pre><code>Vcf()\n</code></pre> <p>Object to manage lazyframe as Vcf.</p> <p>Methods:</p> <ul> <li> <code>add_genotypes</code>             \u2013              <p>Add genotypes information in vcf.</p> </li> <li> <code>annotations</code>             \u2013              <p>Get annotations of vcf.</p> </li> <li> <code>from_path</code>             \u2013              <p>Populate Vcf object with vcf file.</p> </li> <li> <code>genotypes</code>             \u2013              <p>Get genotype of vcf.</p> </li> <li> <code>schema</code>             \u2013              <p>Get schema of Vcf polars.LazyFrame.</p> </li> <li> <code>set_variants</code>             \u2013              <p>Set variants of vcf.</p> </li> <li> <code>variants</code>             \u2013              <p>Get variants of vcf.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Vcf object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n\n    self.header = VcfHeader()\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf.add_genotypes","title":"add_genotypes","text":"<pre><code>add_genotypes(genotypes_lf: Genotypes) -&gt; None\n</code></pre> <p>Add genotypes information in vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def add_genotypes(self, genotypes_lf: Genotypes) -&gt; None:\n    \"\"\"Add genotypes information in vcf.\"\"\"\n    for sample in genotypes_lf.samples_names():\n        geno2sample = (\n            genotypes_lf.lf.filter(polars.col(\"sample\") == sample)\n            .rename(\n                {col: f\"{sample}_{col}\" for col in genotypes_lf.lf.collect_schema().names()[2:]},\n            )\n            .drop(\"sample\")\n        )\n\n        self.lf = self.lf.join(geno2sample, on=\"id\", how=\"full\", coalesce=True)\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf.annotations","title":"annotations","text":"<pre><code>annotations(\n    select_info: set[str] | None = None,\n) -&gt; Annotations\n</code></pre> <p>Get annotations of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def annotations(self, select_info: set[str] | None = None) -&gt; Annotations:\n    \"\"\"Get annotations of vcf.\"\"\"\n    lf = self.lf.with_columns(self.lf.header.info_parser(select_info))\n\n    return lf.drop(\"chr\", \"pos\", \"ref\", \"alt\", \"format\", \"info\")\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path,\n    chr2len_path: Path | None,\n    behavior: VcfParsingBehavior = NOTHING,\n) -&gt; None\n</code></pre> <p>Populate Vcf object with vcf file.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def from_path(\n    self,\n    path: pathlib.Path,\n    chr2len_path: pathlib.Path | None,\n    behavior: VcfParsingBehavior = VcfParsingBehavior.NOTHING,\n) -&gt; None:\n    \"\"\"Populate Vcf object with vcf file.\"\"\"\n    with open(path) as fh:\n        try:\n            self.header.from_lines(fh)\n        except NotVcfHeaderError as e:\n            raise NotAVCFError(path) from e\n\n    chr2len = ContigsLength()\n    if chr2len_path is not None:\n        if chr2len.from_path(chr2len_path) == 0 and chr2len.from_vcf_header(self.header) == 0:\n            raise NoContigsLengthInformationError\n    elif chr2len.from_vcf_header(self.header) == 0:\n        raise NoContigsLengthInformationError\n\n    self.lf = polars.scan_csv(\n        path,\n        separator=\"\\t\",\n        comment_prefix=\"#\",\n        has_header=False,\n        schema_overrides=Vcf.schema(),\n        new_columns=list(Vcf.schema().keys()),\n    )\n\n    schema = self.lf.collect_schema()\n    self.lf = self.lf.rename(dict(zip(schema.names(), self.header.column_name(schema.len()))))\n    self.lf = self.lf.cast(Vcf.schema())  # type: ignore # noqa: PGH003  polars 1.0 typing stuff\n\n    if behavior == VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.with_columns(self.header.info_parser({\"SVTYPE\", \"SVLEN\"}))\n\n    self.lf = normalization.add_variant_id(self.lf, chr2len.lf)\n\n    if behavior == VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.drop(\"SVTYPE\", \"SVLEN\", strict=False)\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf.genotypes","title":"genotypes","text":"<pre><code>genotypes(format_str: str = 'GT:AD:DP:GQ') -&gt; Genotypes\n</code></pre> <p>Get genotype of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def genotypes(self, format_str: str = \"GT:AD:DP:GQ\") -&gt; Genotypes:\n    \"\"\"Get genotype of vcf.\"\"\"\n    schema = self.lf.collect_schema()\n\n    if \"format\" not in schema.names():\n        raise NoGenotypeError\n\n    lf = self.lf.select([*schema.names()[schema.names().index(\"format\") :]])\n    schema = lf.collect_schema()\n\n    # Clean bad variant\n    lf = lf.filter(polars.col(\"format\").str.starts_with(format_str)).select(*schema.names()[1:])\n\n    # Found index of genotype value\n    col_index = {\n        key: index\n        for (index, key) in enumerate(\n            format_str.split(\":\"),\n        )\n    }\n\n    # Pivot value\n    genotypes = Genotypes()\n    genotypes.lf = lf.unpivot(index=[\"id\"]).with_columns(\n        [\n            polars.col(\"id\"),\n            polars.col(\"variable\").alias(\"sample\"),\n            polars.col(\"value\").str.split(\":\"),\n        ],\n    )\n\n    # Split genotype column in sub value\n    col2expr = self.header.format_parser()\n\n    genotypes.lf = genotypes.lf.with_columns(\n        [\n            polars.col(\"value\").list.get(index).pipe(function=col2expr[col], col_name=col)\n            for col, index in col_index.items()\n        ],\n    )\n\n    # Select intrusting column\n    genotypes.lf = genotypes.lf.select([\"id\", \"sample\", *[col.lower() for col in col_index]])\n\n    if \"gt\".upper() in col2expr:\n        genotypes.lf = genotypes.lf.filter(polars.col(\"gt\") != 0)\n\n    return genotypes\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of Vcf polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>@classmethod\ndef schema(cls) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of Vcf polars.LazyFrame.\"\"\"\n    return {\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"vid\": polars.String,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n        \"qual\": polars.String,\n        \"filter\": polars.String,\n        \"info\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf.set_variants","title":"set_variants","text":"<pre><code>set_variants(variants: Variants) -&gt; None\n</code></pre> <p>Set variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def set_variants(self, variants: Variants) -&gt; None:\n    \"\"\"Set variants of vcf.\"\"\"\n    self.lf = variants.lf\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.Vcf.variants","title":"variants","text":"<pre><code>variants() -&gt; Variants\n</code></pre> <p>Get variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def variants(self) -&gt; Variants:\n    \"\"\"Get variants of vcf.\"\"\"\n    return self.lf.select(Variants.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader","title":"VcfHeader","text":"<pre><code>VcfHeader()\n</code></pre> <p>Object that parse and store vcf information.</p> <p>Methods:</p> <ul> <li> <code>column_name</code>             \u2013              <p>Get an iterator of correct column name.</p> </li> <li> <code>format_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract genotypes information.</p> </li> <li> <code>from_files</code>             \u2013              <p>Populate VcfHeader object with content of only header file.</p> </li> <li> <code>from_lines</code>             \u2013              <p>Extract all header information of vcf lines.</p> </li> <li> <code>info_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract variants information.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>contigs</code>               (<code>Iterator[str]</code>)           \u2013            <p>Get an iterator of line contains chromosomes information.</p> </li> <li> <code>samples_index</code>               (<code>dict[str, int] | None</code>)           \u2013            <p>Read vcf header to generate an association map between sample name and index.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise VcfHeader.\"\"\"\n    self._header = []\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader.contigs","title":"contigs  <code>cached</code> <code>property</code>","text":"<pre><code>contigs: Iterator[str]\n</code></pre> <p>Get an iterator of line contains chromosomes information.</p> <p>Returns: String iterator</p>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader.samples_index","title":"samples_index  <code>cached</code> <code>property</code>","text":"<pre><code>samples_index: dict[str, int] | None\n</code></pre> <p>Read vcf header to generate an association map between sample name and index.</p> <p>Args: header: Header string.</p> <p>Returns: Map that associate a sample name to is sample index.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader.column_name","title":"column_name","text":"<pre><code>column_name(\n    number_of_column: int = MINIMAL_COL_NUMBER,\n) -&gt; Iterator[str]\n</code></pre> <p>Get an iterator of correct column name.</p> <p>Returns: String iterator</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def column_name(self, number_of_column: int = MINIMAL_COL_NUMBER) -&gt; typing.Iterator[str]:\n    \"\"\"Get an iterator of correct column name.\n\n    Returns: String iterator\n    \"\"\"\n    base_col_name = [\"chr\", \"pos\", \"vid\", \"ref\", \"alt\", \"qual\", \"filter\", \"info\"]\n\n    yield from base_col_name\n\n    if number_of_column &gt; MINIMAL_COL_NUMBER and (samples := self.samples_index):\n        yield \"format\"\n        yield from (sample for (sample, _) in samples.items())\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader.format_parser","title":"format_parser","text":"<pre><code>format_parser(\n    select_format: set[str] | None = None,\n) -&gt; dict[str, Callable[[Expr, str], Expr]]\n</code></pre> <p>Generate a list of polars.Expr to extract genotypes information.</p> <p>Warning: Float values can't be converted for the moment they are stored as String to keep information</p> <p>Args: header: Line of vcf header. input_path: Path to vcf file. select_format: List of target format field.</p> <p>Returns: A dict to link format id to pipeable function with Polars.Expr</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def format_parser(\n    self,\n    select_format: set[str] | None = None,\n) -&gt; dict[str, typing.Callable[[polars.Expr, str], polars.Expr]]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract genotypes information.\n\n    **Warning**: Float values can't be converted for the moment they are stored as String to keep information\n\n    Args:\n    header: Line of vcf header.\n    input_path: Path to vcf file.\n    select_format: List of target format field.\n\n    Returns:\n    A dict to link format id to pipeable function with Polars.Expr\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    format_re = re.compile(\n        \"ID=(?P&lt;id&gt;[A-Za-z_][0-9A-Za-z_.]*),Number=(?P&lt;number&gt;[ARG0-9\\\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: dict[str, typing.Callable[[polars.Expr, str], polars.Expr]] = {}\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##FORMAT\"):\n            continue\n\n        if (search := format_re.search(line)) and (not select_format or search[\"id\"] in select_format):\n            name = search[\"id\"]\n            number = search[\"number\"]\n            format_type = search[\"type\"]\n\n            if name == \"GT\":\n                expressions[\"GT\"] = VcfHeader.__format_gt\n                continue\n\n            if number == \"1\":\n                if format_type == \"Integer\":\n                    expressions[name] = VcfHeader.__format_one_int\n                elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                    expressions[name] = VcfHeader.__format_one_str\n                elif format_type in {\"String\", \"Character\"}:\n                    expressions[name] = VcfHeader.__format_one_str\n                else:\n                    pass  # Not reachable\n\n            elif format_type == \"Integer\":\n                expressions[name] = VcfHeader.__format_list_int\n            elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                expressions[name] = VcfHeader.__format_list_str\n            elif format_type in {\"String\", \"Character\"}:\n                expressions[name] = VcfHeader.__format_list_str\n            else:\n                pass  # Not reachable\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader.from_files","title":"from_files","text":"<pre><code>from_files(path: Path) -&gt; None\n</code></pre> <p>Populate VcfHeader object with content of only header file.</p> <p>Args: path: Path of file</p> <p>Returns: None</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_files(self, path: pathlib.Path) -&gt; None:\n    \"\"\"Populate VcfHeader object with content of only header file.\n\n    Args:\n    path: Path of file\n\n    Returns:\n    None\n    \"\"\"\n    with open(path) as fh:\n        for full_line in fh:\n            line = full_line.strip()\n            self._header.append(line)\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader.from_lines","title":"from_lines","text":"<pre><code>from_lines(lines: Iterator[str]) -&gt; None\n</code></pre> <p>Extract all header information of vcf lines.</p> <p>Line between start of file and first line start with '#CHROM' or not start with '#'</p> <p>Args: lines: Iterator of line</p> <p>Returns: None</p> <p>Raises: NotAVcfHeader: If a line not starts with '#' NotAVcfHeader: If no line start by '#CHROM'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_lines(self, lines: typing.Iterator[str]) -&gt; None:\n    \"\"\"Extract all header information of vcf lines.\n\n    Line between start of file and first line start with '#CHROM' or not start with '#'\n\n    Args:\n    lines: Iterator of line\n\n    Returns: None\n\n    Raises:\n    NotAVcfHeader: If a line not starts with '#'\n    NotAVcfHeader: If no line start by '#CHROM'\n    \"\"\"\n    for full_line in lines:\n        line = full_line.strip()\n\n        if not line.startswith(\"#\"):\n            raise NotVcfHeaderError\n\n        if line.startswith(\"#CHROM\"):\n            self._header.append(line)\n            return\n\n        self._header.append(line)\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.VcfHeader.info_parser","title":"info_parser","text":"<pre><code>info_parser(\n    select_info: set[str] | None = None,\n) -&gt; list[Expr]\n</code></pre> <p>Generate a list of polars.Expr to extract variants information.</p> <p>Args: header: Line of vcf header input_path: Path to vcf file. select_info: List of target info field</p> <p>Returns: List of polars.Expr to parse info columns.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def info_parser(self, select_info: set[str] | None = None) -&gt; list[polars.Expr]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract variants information.\n\n    Args:\n    header: Line of vcf header\n    input_path: Path to vcf file.\n    select_info: List of target info field\n\n    Returns:\n    List of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to parse info columns.\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    info_re = re.compile(\n        r\"ID=(?P&lt;id&gt;([A-Za-z_][0-9A-Za-z_.]*|1000G)),Number=(?P&lt;number&gt;[ARG0-9\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: list[polars.Expr] = []\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##INFO\"):\n            continue\n\n        if (search := info_re.search(line)) and (not select_info or search[\"id\"] in select_info):\n            regex = rf\"{search['id']}=([^;]+);?\"\n\n            local_expr = polars.col(\"info\").str.extract(regex, 1)\n\n            if search[\"number\"] == \"1\":\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.Int64)\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.Float64)\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            else:\n                local_expr = local_expr.str.split(\",\")\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.List(polars.Int64))\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.List(polars.Float64))\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            expressions.append(local_expr.alias(search[\"id\"]))\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/#variantplaner.VcfParsingBehavior","title":"VcfParsingBehavior","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration use to control behavior of IntoLazyFrame.</p> <p>Attributes:</p> <ul> <li> <code>MANAGE_SV</code>           \u2013            <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p> </li> <li> <code>NOTHING</code>           \u2013            <p>into_lazyframe not have any specific behavior</p> </li> </ul>"},{"location":"reference/variantplaner/#variantplaner.VcfParsingBehavior.MANAGE_SV","title":"MANAGE_SV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MANAGE_SV = 1\n</code></pre> <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p>"},{"location":"reference/variantplaner/#variantplaner.VcfParsingBehavior.NOTHING","title":"NOTHING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOTHING = 0\n</code></pre> <p>into_lazyframe not have any specific behavior</p>"},{"location":"reference/variantplaner/debug/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> debug","text":""},{"location":"reference/variantplaner/debug/#variantplaner.debug","title":"debug","text":"<p>Debugging utilities.</p> <p>Classes:</p> <ul> <li> <code>Environment</code>           \u2013            <p>Dataclass to store environment information.</p> </li> <li> <code>Package</code>           \u2013            <p>Dataclass describing a Python package.</p> </li> <li> <code>Variable</code>           \u2013            <p>Dataclass describing an environment variable.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_debug_info</code>             \u2013              <p>Get debug/environment information.</p> </li> <li> <code>get_version</code>             \u2013              <p>Get version of the given distribution.</p> </li> <li> <code>print_info</code>             \u2013              <p>Print debug/environment information.</p> </li> </ul>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Environment","title":"Environment  <code>dataclass</code>","text":"<pre><code>Environment(\n    interpreter_name: str,\n    interpreter_version: str,\n    platform: str,\n    packages: list[Package],\n    variables: list[Variable],\n)\n</code></pre> <p>Dataclass to store environment information.</p> <p>Attributes:</p> <ul> <li> <code>interpreter_name</code>               (<code>str</code>)           \u2013            <p>Python interpreter name.</p> </li> <li> <code>interpreter_version</code>               (<code>str</code>)           \u2013            <p>Python interpreter version.</p> </li> <li> <code>packages</code>               (<code>list[Package]</code>)           \u2013            <p>Installed packages.</p> </li> <li> <code>platform</code>               (<code>str</code>)           \u2013            <p>Operating System.</p> </li> <li> <code>variables</code>               (<code>list[Variable]</code>)           \u2013            <p>Environment variables.</p> </li> </ul>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Environment.interpreter_name","title":"interpreter_name  <code>instance-attribute</code>","text":"<pre><code>interpreter_name: str\n</code></pre> <p>Python interpreter name.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Environment.interpreter_version","title":"interpreter_version  <code>instance-attribute</code>","text":"<pre><code>interpreter_version: str\n</code></pre> <p>Python interpreter version.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Environment.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages: list[Package]\n</code></pre> <p>Installed packages.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Environment.platform","title":"platform  <code>instance-attribute</code>","text":"<pre><code>platform: str\n</code></pre> <p>Operating System.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Environment.variables","title":"variables  <code>instance-attribute</code>","text":"<pre><code>variables: list[Variable]\n</code></pre> <p>Environment variables.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Package","title":"Package  <code>dataclass</code>","text":"<pre><code>Package(name: str, version: str)\n</code></pre> <p>Dataclass describing a Python package.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Package name.</p> </li> <li> <code>version</code>               (<code>str</code>)           \u2013            <p>Package version.</p> </li> </ul>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Package.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Package name.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Package.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: str\n</code></pre> <p>Package version.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Variable","title":"Variable  <code>dataclass</code>","text":"<pre><code>Variable(name: str, value: str)\n</code></pre> <p>Dataclass describing an environment variable.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Variable name.</p> </li> <li> <code>value</code>               (<code>str</code>)           \u2013            <p>Variable value.</p> </li> </ul>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Variable.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>Variable name.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.Variable.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str\n</code></pre> <p>Variable value.</p>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.get_debug_info","title":"get_debug_info","text":"<pre><code>get_debug_info() -&gt; Environment\n</code></pre> <p>Get debug/environment information.</p> <p>Returns:</p> <ul> <li> <code>Environment</code>           \u2013            <p>Environment information.</p> </li> </ul> Source code in <code>src/variantplaner/debug.py</code> <pre><code>def get_debug_info() -&gt; Environment:\n    \"\"\"Get debug/environment information.\n\n    Returns:\n        Environment information.\n    \"\"\"\n    py_name, py_version = _interpreter_name_version()\n    packages = [\"variantplaner\"]\n    variables = [\n        \"PYTHONPATH\",\n        *[var for var in os.environ if var.startswith(\"VARIANTPLANER\")],\n    ]\n    return Environment(\n        interpreter_name=py_name,\n        interpreter_version=py_version,\n        platform=platform.platform(),\n        variables=[Variable(var, val) for var in variables if (val := os.getenv(var))],\n        packages=[Package(pkg, get_version(pkg)) for pkg in packages],\n    )\n</code></pre>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.get_version","title":"get_version","text":"<pre><code>get_version(dist: str = 'variantplaner') -&gt; str\n</code></pre> <p>Get version of the given distribution.</p> <p>Parameters:</p> <ul> <li> <code>dist</code>               (<code>str</code>, default:                   <code>'variantplaner'</code> )           \u2013            <p>A distribution name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A version number.</p> </li> </ul> Source code in <code>src/variantplaner/debug.py</code> <pre><code>def get_version(dist: str = \"variantplaner\") -&gt; str:\n    \"\"\"Get version of the given distribution.\n\n    Parameters:\n        dist: A distribution name.\n\n    Returns:\n        A version number.\n    \"\"\"\n    try:\n        return metadata.version(dist)\n    except metadata.PackageNotFoundError:\n        return \"0.0.0\"\n</code></pre>"},{"location":"reference/variantplaner/debug/#variantplaner.debug.print_info","title":"print_info","text":"<pre><code>print_info() -&gt; None\n</code></pre> <p>Print debug/environment information.</p> Source code in <code>src/variantplaner/debug.py</code> <pre><code>def print_info() -&gt; None:\n    \"\"\"Print debug/environment information.\"\"\"\n    info = get_debug_info()\n    print(f\"- __System__: {info.platform}\")\n    print(f\"- __Python__: {info.interpreter_name} {info.interpreter_version}\")\n    print(\"- __Environment variables__:\")\n    for var in info.variables:\n        print(f\"  - `{var.name}`: `{var.value}`\")\n    print(\"- __Installed packages__:\")\n    for pkg in info.packages:\n        print(f\"  - `{pkg.name}` v{pkg.version}\")\n</code></pre>"},{"location":"reference/variantplaner/exception/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> exception","text":""},{"location":"reference/variantplaner/exception/#variantplaner.exception","title":"exception","text":"<p>Exception could be generate by VariantPlanner.</p> <p>Classes:</p> <ul> <li> <code>NoContigsLengthInformationError</code>           \u2013            <p>Exception raise if we didn't get Contigs Length information in vcf or in compagnion file.</p> </li> <li> <code>NoGTError</code>           \u2013            <p>Exception raise if genotype polars.LazyFrame not contains gt column.</p> </li> <li> <code>NoGenotypeError</code>           \u2013            <p>Exception raise if vcf file seems not contains genotypes information.</p> </li> <li> <code>NotAVCFError</code>           \u2013            <p>Exception raise if file read seems not be a vcf, generally not contains a line starts with '#CHROM'.</p> </li> <li> <code>NotAVariantCsvError</code>           \u2013            <p>Exception raise if file is a csv should contains variants info but columns name not match minimal requirement.</p> </li> <li> <code>NotVcfHeaderError</code>           \u2013            <p>Exception raise if header isn't compatible with vcf.</p> </li> </ul>"},{"location":"reference/variantplaner/exception/#variantplaner.exception.NoContigsLengthInformationError","title":"NoContigsLengthInformationError","text":"<pre><code>NoContigsLengthInformationError()\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raise if we didn't get Contigs Length information in vcf or in compagnion file.</p> Source code in <code>src/variantplaner/exception.py</code> <pre><code>def __init__(self):\n    \"\"\"Initize no contigs length information error.\"\"\"\n    super().__init__(\"Contigs length information is required in vcf header of in compagnion file.\")\n</code></pre>"},{"location":"reference/variantplaner/exception/#variantplaner.exception.NoGTError","title":"NoGTError","text":"<pre><code>NoGTError(message: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raise if genotype polars.LazyFrame not contains gt column.</p> Source code in <code>src/variantplaner/exception.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"Initialize no gt error.\"\"\"\n    super().__init__(f\"In {message} gt column is missing.\")\n</code></pre>"},{"location":"reference/variantplaner/exception/#variantplaner.exception.NoGenotypeError","title":"NoGenotypeError","text":"<pre><code>NoGenotypeError()\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raise if vcf file seems not contains genotypes information.</p> Source code in <code>src/variantplaner/exception.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize no genotype error.\"\"\"\n    super().__init__(\"LazyFrame seems not contains genotypes.\")\n</code></pre>"},{"location":"reference/variantplaner/exception/#variantplaner.exception.NotAVCFError","title":"NotAVCFError","text":"<pre><code>NotAVCFError(path: Path)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raise if file read seems not be a vcf, generally not contains a line starts with '#CHROM'.</p> Source code in <code>src/variantplaner/exception.py</code> <pre><code>def __init__(self, path: pathlib.Path):\n    \"\"\"Initialize not a vcf error.\"\"\"\n    super().__init__(f\"File {path} seems not be a valid vcf file.\")\n</code></pre>"},{"location":"reference/variantplaner/exception/#variantplaner.exception.NotAVariantCsvError","title":"NotAVariantCsvError","text":"<pre><code>NotAVariantCsvError(path: Path)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raise if file is a csv should contains variants info but columns name not match minimal requirement.</p> Source code in <code>src/variantplaner/exception.py</code> <pre><code>def __init__(self, path: pathlib.Path):\n    \"\"\"Initialize not a variant csv error.\"\"\"\n    super().__init__(f\"{path} seems not be a csv variant.\")\n</code></pre>"},{"location":"reference/variantplaner/exception/#variantplaner.exception.NotVcfHeaderError","title":"NotVcfHeaderError","text":"<pre><code>NotVcfHeaderError()\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raise if header isn't compatible with vcf.</p> Source code in <code>src/variantplaner/exception.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize not a vcf header error.\"\"\"\n    super().__init__(\"Not a vcf header\")\n</code></pre>"},{"location":"reference/variantplaner/extract/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> extract","text":""},{"location":"reference/variantplaner/extract/#variantplaner.extract","title":"extract","text":"<p>Extract information of polars.LazyFrame produce from raw vcf file parsing.</p> <p>Functions:</p> <ul> <li> <code>genotypes</code>             \u2013              <p>Extract genotypes information of raw polars.LazyFrame.</p> </li> <li> <code>variants</code>             \u2013              <p>Extract variants only information of polars.LazyFrame.</p> </li> </ul>"},{"location":"reference/variantplaner/extract/#variantplaner.extract.genotypes","title":"genotypes","text":"<pre><code>genotypes(\n    lf: LazyFrame,\n    col2expr: dict[str, Callable[[Expr, str], Expr]],\n    format_str: str = \"GT:AD:DP:GQ\",\n) -&gt; LazyFrame\n</code></pre> <p>Extract genotypes information of raw polars.LazyFrame.</p> <p>Only line with format value match <code>format_str</code> are considered.</p> <p>Parameters:</p> <ul> <li> <code>lf</code>               (<code>LazyFrame</code>)           \u2013            <p>The target polars.LazyFrame</p> </li> <li> <code>col2expr</code>               (<code>dict[str, Callable[[Expr, str], Expr]]</code>)           \u2013            <p>A dict associate column name and function to apply to create polars.LazyFrame column (produce by io.vcf.format2expr)</p> </li> <li> <code>format_str</code>               (<code>str</code>, default:                   <code>'GT:AD:DP:GQ'</code> )           \u2013            <p>Only variants match with this string format are considered</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LazyFrame</code>           \u2013            <p>A polars.LazyFrame with variant id, sample information and genotypes information</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoGenotypeError</code>             \u2013            <p>If none of the lf columns is equal to 'format'</p> </li> </ul> Source code in <code>src/variantplaner/extract.py</code> <pre><code>def genotypes(\n    lf: polars.LazyFrame,\n    col2expr: dict[str, Callable[[polars.Expr, str], polars.Expr]],\n    format_str: str = \"GT:AD:DP:GQ\",\n) -&gt; polars.LazyFrame:\n    \"\"\"Extract genotypes information of raw [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html).\n\n    Only line with format value match `format_str` are considered.\n\n    Args:\n        lf: The target [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html)\n        col2expr: A dict associate column name and function to apply to create [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) column (produce by io.vcf.format2expr)\n        format_str: Only variants match with this string format are considered\n\n    Returns:\n        A [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) with variant id, sample information and genotypes information\n\n    Raises:\n        NoGenotypeError: If none of the lf columns is equal to 'format'\n    \"\"\"\n    if \"format\" not in lf.columns:\n        raise NoGenotypeError\n\n    lf = lf.select([*lf.columns[lf.columns.index(\"format\") :]])\n\n    # Clean bad variant\n    lf = lf.filter(polars.col(\"format\").str.starts_with(format_str)).select(*lf.columns[1:])\n\n    # Found index of genotype value\n    col_index = {\n        key: index\n        for (index, key) in enumerate(\n            format_str.split(\":\"),\n        )\n    }\n\n    # Pivot value\n    genotypes = lf.melt(id_vars=[\"id\"]).with_columns(\n        [\n            polars.col(\"id\"),\n            polars.col(\"variable\").alias(\"sample\"),\n            polars.col(\"value\").str.split(\":\"),\n        ],\n    )\n\n    # Split genotype column in sub value\n    genotypes = genotypes.with_columns(\n        [\n            polars.col(\"value\").list.get(index).pipe(function=col2expr[col], name=col)  # type: ignore # noqa: PGH003\n            for col, index in col_index.items()\n        ],\n    )\n\n    # Select intrusting column\n    genotypes = genotypes.select([\"id\", \"sample\", *[col.lower() for col in col_index]])\n\n    if \"gt\" in genotypes.columns:\n        return genotypes.filter(polars.col(\"gt\") != 0)\n\n    return genotypes\n</code></pre>"},{"location":"reference/variantplaner/extract/#variantplaner.extract.variants","title":"variants","text":"<pre><code>variants(lf: LazyFrame) -&gt; LazyFrame\n</code></pre> <p>Extract variants only information of polars.LazyFrame.</p> <p>Parameters:</p> <ul> <li> <code>lf</code>               (<code>LazyFrame</code>)           \u2013            <p>A polars.LazyFrame</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LazyFrame</code>           \u2013            <p>A polars.LazyFrame with just variant information (id, chr, pos, ref, alt)</p> </li> </ul> Source code in <code>src/variantplaner/extract.py</code> <pre><code>def variants(lf: polars.LazyFrame) -&gt; polars.LazyFrame:\n    \"\"\"Extract variants only information of polars.LazyFrame.\n\n    Args:\n        lf: A [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html)\n\n    Returns:\n        A [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) with just variant information (id, chr, pos, ref, alt)\n    \"\"\"\n    return lf.select(\n        [\n            polars.col(\"id\"),\n            polars.col(\"chr\"),\n            polars.col(\"pos\"),\n            polars.col(\"ref\"),\n            polars.col(\"alt\"),\n        ],\n    )\n</code></pre>"},{"location":"reference/variantplaner/generate/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> generate","text":""},{"location":"reference/variantplaner/generate/#variantplaner.generate","title":"generate","text":"<p>Function to generate information.</p> <p>Functions:</p> <ul> <li> <code>transmission</code>             \u2013              <p>Compute how each variant are transmite to index case.</p> </li> <li> <code>transmission_ped</code>             \u2013              <p>Compute transmission of each variants.</p> </li> </ul>"},{"location":"reference/variantplaner/generate/#variantplaner.generate.transmission","title":"transmission","text":"<pre><code>transmission(\n    genotypes_lf: LazyFrame,\n    index_name: str,\n    mother_name: str | None = None,\n    father_name: str | None = None,\n) -&gt; DataFrame\n</code></pre> <p>Compute how each variant are transmite to index case.</p> <p>Parameters:</p> <ul> <li> <code>genotypes_lf</code>               (<code>LazyFrame</code>)           \u2013            <p>Genotypes polars.LazyFrame, <code>gt</code> column are required.</p> </li> <li> <code>index_name</code>               (<code>str</code>)           \u2013            <p>Sample name of index case.</p> </li> <li> <code>mother_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Sample name of mother.</p> </li> <li> <code>father_name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Sample name of father.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>polars.DataFrame with transmission information. With genotyping information for index, mother and father. If any of them isn't present value are set to polars.Null. Columns transmission contains a string: concat(chr(index_gt + 33), chr(mother_gt + 33), chr(father_gt + 33)), transmission: <code>#~!</code> mean homozygote diploide variant not present in father but with no information about mother.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoGTError</code>             \u2013            <p>if genotypes_lf not containts gt column.</p> </li> </ul> Source code in <code>src/variantplaner/generate.py</code> <pre><code>def transmission(\n    genotypes_lf: polars.LazyFrame,\n    index_name: str,\n    mother_name: str | None = None,\n    father_name: str | None = None,\n) -&gt; polars.DataFrame:\n    \"\"\"Compute how each variant are transmite to index case.\n\n    Args:\n        genotypes_lf: Genotypes [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html), `gt` column are required.\n        index_name: Sample name of index case.\n        mother_name: Sample name of mother.\n        father_name: Sample name of father.\n\n    Returns:\n         [polars.DataFrame](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/index.html) with transmission information. With genotyping information for index, mother and father. If any of them isn't present value are set to polars.Null. Columns transmission contains a string: concat(chr(index_gt + 33), chr(mother_gt + 33), chr(father_gt + 33)), transmission: `#~!` mean homozygote diploide variant not present in father but with no information about mother.\n\n    Raises:\n        NoGTError: if genotypes_lf not containts gt column.\n    \"\"\"\n    genotypes_column = list(genotypes_lf.collect_schema().names()[2:])\n    if \"gt\" not in genotypes_column:\n        raise NoGTError(\"genotype polars.LazyFrame\")\n\n    samples = sorted(genotypes_lf.select(\"sample\").unique().collect().get_column(\"sample\").to_list())\n\n    logger.debug(f\"{samples=}\")\n\n    genotypes_df = genotypes_lf.collect()\n\n    index_df = (\n        genotypes_df.filter(polars.col(\"sample\") == index_name)\n        .rename({colname: f\"index_{colname}\" for colname in genotypes_column})\n        .drop(\"sample\")\n    )\n\n    if mother_name is None:\n        mother_df = polars.DataFrame(schema=genotypes_df.schema)\n    else:\n        mother_df = genotypes_df.filter(polars.col(\"sample\") == mother_name)\n    mother_df = mother_df.rename({colname: f\"mother_{colname}\" for colname in genotypes_column}).drop(\"sample\")\n\n    if father_name is None:\n        father_df = polars.DataFrame(schema=genotypes_df.schema)\n    else:\n        father_df = genotypes_df.filter(polars.col(\"sample\") == father_name)\n    father_df = father_df.rename({colname: f\"father_{colname}\" for colname in genotypes_column}).drop(\"sample\")\n\n    parent_df = mother_df.join(father_df, on=\"id\", how=\"full\", coalesce=True)\n    transmission_df = index_df.join(parent_df, on=\"id\", how=\"left\")\n\n    if father_name is not None:\n        transmission_df = transmission_df.with_columns(father_gt=polars.col(\"father_gt\").fill_null(strategy=\"zero\"))\n    if mother_name is not None:\n        transmission_df = transmission_df.with_columns(mother_gt=polars.col(\"mother_gt\").fill_null(strategy=\"zero\"))\n\n    return transmission_df.with_columns(\n        polars.concat_str(\n            polars.col(\"index_gt\").replace_strict(gt2chr, default=\"~\", return_dtype=polars.Utf8),\n            polars.col(\"mother_gt\").fill_null(94).replace_strict(gt2chr, default=\"~\", return_dtype=polars.Utf8),\n            polars.col(\"father_gt\").fill_null(94).replace_strict(gt2chr, default=\"~\", return_dtype=polars.Utf8),\n        ).alias(\"origin\"),\n    )\n</code></pre>"},{"location":"reference/variantplaner/generate/#variantplaner.generate.transmission_ped","title":"transmission_ped","text":"<pre><code>transmission_ped(\n    genotypes_lf: LazyFrame, pedigree_lf: LazyFrame\n) -&gt; DataFrame\n</code></pre> <p>Compute transmission of each variants.</p> <p>Warning: only the first sample with two parent are considered.</p> <p>Parameters:</p> <ul> <li> <code>genotypes_lf</code>               (<code>LazyFrame</code>)           \u2013            <p>Genotypes polars.LazyFrame, <code>gt</code> column are required.</p> </li> <li> <code>pedigree_lf</code>               (<code>LazyFrame</code>)           \u2013            <p>Pedigree polars.LazyFrame.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DataFrame</code>           \u2013            <p>DataFrame with transmission information</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NoGTError</code>             \u2013            <p>If genotypes_lf not contains gt column.</p> </li> </ul> Source code in <code>src/variantplaner/generate.py</code> <pre><code>def transmission_ped(\n    genotypes_lf: polars.LazyFrame,\n    pedigree_lf: polars.LazyFrame,\n) -&gt; polars.DataFrame:\n    \"\"\"Compute transmission of each variants.\n\n    **Warning**: only the first sample with two parent are considered.\n\n    Args:\n        genotypes_lf: Genotypes [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html), `gt` column are required.\n        pedigree_lf: Pedigree [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html).\n\n    Returns:\n         DataFrame with transmission information\n\n    Raises:\n        NoGTError: If genotypes_lf not contains gt column.\n    \"\"\"\n    pedigree_df = pedigree_lf.collect()\n\n    first_sample = pedigree_df.get_column(\"personal_id\").to_list()[0]\n\n    pedigree_df = pedigree_df.filter(polars.col(\"father_id\").is_not_null() | polars.col(\"mother_id\").is_not_null())\n\n    if pedigree_df.height &gt; 0:\n        familly_info = pedigree_df.row(0, named=True)\n        return transmission(\n            genotypes_lf,\n            familly_info[\"personal_id\"],\n            familly_info[\"mother_id\"],\n            familly_info[\"father_id\"],\n        )\n    familly_info = {\"personal_id\": first_sample, \"mother_id\": None, \"father_id\": None}\n    return transmission(\n        genotypes_lf,\n        first_sample,\n        None,\n        None,\n    )\n</code></pre>"},{"location":"reference/variantplaner/normalization/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> normalization","text":""},{"location":"reference/variantplaner/normalization/#variantplaner.normalization","title":"normalization","text":"<p>Function use to normalize data.</p> <p>Functions:</p> <ul> <li> <code>add_id_part</code>             \u2013              <p>Add column id part.</p> </li> <li> <code>add_variant_id</code>             \u2013              <p>Add a column id of variants.</p> </li> </ul>"},{"location":"reference/variantplaner/normalization/#variantplaner.normalization.add_id_part","title":"add_id_part","text":"<pre><code>add_id_part(\n    lf: LazyFrame, number_of_bits: int = 8\n) -&gt; LazyFrame\n</code></pre> <p>Add column id part.</p> <p>If id is large variant id value, id_part are set to 255, other value most weigthed position 8 bits are use.</p> <p>Parameters:</p> <ul> <li> <code>lf</code>               (<code>LazyFrame</code>)           \u2013            <p>polars.LazyFrame contains: id column.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LazyFrame</code>           \u2013            <p>polars.LazyFrame with column id_part added</p> </li> </ul> Source code in <code>src/variantplaner/normalization.py</code> <pre><code>def add_id_part(lf: polars.LazyFrame, number_of_bits: int = 8) -&gt; polars.LazyFrame:\n    \"\"\"Add column id part.\n\n    If id is large variant id value, id_part are set to 255, other value most weigthed position 8 bits are use.\n\n    Args:\n        lf: [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) contains: id column.\n\n    Returns:\n        [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) with column id_part added\n    \"\"\"\n    return lf.with_columns(id_part=polars.col(\"id\").variant_id.partition(number_of_bits=number_of_bits))  # type: ignore # noqa: PGH003\n</code></pre>"},{"location":"reference/variantplaner/normalization/#variantplaner.normalization.add_variant_id","title":"add_variant_id","text":"<pre><code>add_variant_id(\n    lf: LazyFrame, chrom2length: LazyFrame\n) -&gt; LazyFrame\n</code></pre> <p>Add a column id of variants.</p> <p>Id computation is based on</p> <p>Two different algorithms are used to calculate the variant identifier, depending on the cumulative length of the reference and alternative sequences.</p> <p>If the cumulative length of the reference and alternative sequences is short, the leftmost bit of the id is set to 0, then a unique 63-bit hash of the variant is calculated.</p> <p>If the cumulative length of the reference and alternative sequences is long, the right-most bit of the id will have a value of 1, followed by a hash function, used in Firefox, of the chromosome, position, reference and alternative sequence without the right-most bit.</p> <p>If lf.columns contains SVTYPE and SVLEN variant with regex group in alt &lt;([^:]+).*&gt; match SVTYPE are replaced by concatenation of SVTYPE and SVLEN first value.</p> <p>Parameters:</p> <ul> <li> <code>lf</code>               (<code>LazyFrame</code>)           \u2013            <p>polars.LazyFrame contains: chr, pos, ref, alt columns.</p> </li> <li> <code>chrom2length</code>               (<code>LazyFrame</code>)           \u2013            <p>polars.DataFrame contains: chr and length columns.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>LazyFrame</code>           \u2013            <p>polars.LazyFrame with chr column normalized</p> </li> </ul> Source code in <code>src/variantplaner/normalization.py</code> <pre><code>def add_variant_id(lf: polars.LazyFrame, chrom2length: polars.LazyFrame) -&gt; polars.LazyFrame:\n    \"\"\"Add a column id of variants.\n\n    Id computation is based on\n\n    Two different algorithms are used to calculate the variant identifier, depending on the cumulative length of the reference and alternative sequences.\n\n    If the cumulative length of the reference and alternative sequences is short, the leftmost bit of the id is set to 0, then a unique 63-bit hash of the variant is calculated.\n\n    If the cumulative length of the reference and alternative sequences is long, the right-most bit of the id will have a value of 1, followed by a hash function, used in Firefox, of the chromosome, position, reference and alternative sequence without the right-most bit.\n\n    If lf.columns contains SVTYPE and SVLEN variant with regex group in alt &lt;([^:]+).*&gt; match SVTYPE are replaced by concatenation of SVTYPE and SVLEN first value.\n\n    Args:\n        lf: [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) contains: chr, pos, ref, alt columns.\n        chrom2length: [polars.DataFrame](https://pola-rs.github.io/polars/py-polars/html/reference/dataframe/index.html) contains: chr and length columns.\n\n    Returns:\n        [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) with chr column normalized\n    \"\"\"\n    real_pos_max = chrom2length.select([polars.col(\"length\").sum()]).collect().get_column(\"length\").max()\n\n    large_variant_len = (64 - len(format(real_pos_max, \"b\")) - 2) // 2 + 1\n\n    col_names = lf.collect_schema().names()\n    if \"SVTYPE\" in col_names and \"SVLEN\" in col_names:\n        lf = lf.with_columns(\n            alt=polars.when(\n                polars.col(\"alt\").str.replace(\"&lt;(?&lt;type&gt;[^:]+).*&gt;\", \"$type\") == polars.col(\"SVTYPE\"),\n            )\n            .then(\n                polars.col(\"alt\")\n                .str.replace(\n                    \".+\",\n                    polars.concat_str(\n                        [polars.col(\"SVTYPE\"), polars.col(\"SVLEN\").list.get(0)],\n                        separator=\"-\",\n                    ),\n                )\n                .str.pad_end(large_variant_len, \"-\"),\n            )\n            .otherwise(\n                polars.col(\"alt\"),\n            ),\n        )\n\n    lf = lf.with_columns(alt=polars.col(\"alt\").str.replace(\"\\\\*\", \"*\" * large_variant_len))\n    lf = lf.join(chrom2length, right_on=\"contig\", left_on=\"chr\", how=\"left\", coalesce=True)\n    lf = lf.with_columns(real_pos=polars.col(\"pos\") + polars.col(\"offset\"))\n\n    lf = lf.with_columns(\n        id=polars.col(\"real_pos\").variant_id.compute(  # type: ignore # noqa: PGH003\n            polars.col(\"ref\"),\n            polars.col(\"alt\"),\n            real_pos_max,\n        ),\n    )\n\n    return lf.drop([\"real_pos\", \"length\", \"offset\"])\n</code></pre>"},{"location":"reference/variantplaner/cli/","title":"Index","text":""},{"location":"reference/variantplaner/cli/#variantplaner.cli","title":"cli","text":"<p>Module contains command line entry point function.</p> <p>Modules:</p> <ul> <li> <code>debug</code>           \u2013            <p>Debugging utilities.</p> </li> <li> <code>metadata</code>           \u2013            <p>Module contains command line entry point function.</p> </li> <li> <code>parquet2vcf</code>           \u2013            <p>Module contains parquet2vcf subcommand entry point function.</p> </li> <li> <code>struct</code>           \u2013            <p>Module contains struct subcommand entry point function.</p> </li> <li> <code>transmission</code>           \u2013            <p>Module contains transmission subcommand entry point function.</p> </li> <li> <code>vcf2parquet</code>           \u2013            <p>Module contains vcf2parquet subcommand entry point function.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>MultipleValueOption</code>           \u2013            <p>Class use to manage option with variadic value.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>main</code>             \u2013              <p>Run VariantPlanner.</p> </li> </ul>"},{"location":"reference/variantplaner/cli/#variantplaner.cli.MultipleValueOption","title":"MultipleValueOption","text":"<pre><code>MultipleValueOption(\n    *args: list[Any], **kwargs: dict[Any, Any]\n)\n</code></pre> <p>               Bases: <code>Option</code></p> <p>Class use to manage option with variadic value.</p> <p>Methods:</p> <ul> <li> <code>add_to_parser</code>             \u2013              <p>Add parser.</p> </li> </ul> Source code in <code>src/variantplaner/cli/__init__.py</code> <pre><code>def __init__(self, *args: list[typing.Any], **kwargs: dict[typing.Any, typing.Any]):\n    \"\"\"Intialise click option parser.\"\"\"\n    super(MultipleValueOption, self).__init__(*args, **kwargs)  # type: ignore[arg-type] # noqa: UP008  false positive and complexe type\n    self._previous_parser_process = None\n    self._eat_all_parser = None\n</code></pre>"},{"location":"reference/variantplaner/cli/#variantplaner.cli.MultipleValueOption.add_to_parser","title":"add_to_parser","text":"<pre><code>add_to_parser(parser: Any, ctx: Any) -&gt; Any\n</code></pre> <p>Add parser.</p> Source code in <code>src/variantplaner/cli/__init__.py</code> <pre><code>def add_to_parser(self, parser: typing.Any, ctx: typing.Any) -&gt; typing.Any:\n    \"\"\"Add parser.\"\"\"\n\n    def parser_process(value: typing.Any, state: typing.Any) -&gt; typing.Any:\n        # method to hook to the parser.process\n        done = False\n        value = [value]\n\n        # grab everything up to the next option\n        while state.rargs and not done:\n            if self._eat_all_parser:\n                for prefix in self._eat_all_parser.prefixes:\n                    if not state.rargs or state.rargs[0].startswith(prefix):\n                        done = True\n                    if not done:\n                        value.append(state.rargs.pop(0))\n\n        if len(value) == 1:\n            value = value[0]\n        else:\n            value = tuple(value)\n            self.nargs = len(value)\n\n        # call the actual process\n        if self._previous_parser_process:\n            self._previous_parser_process(value, state)\n\n    retval = super(MultipleValueOption, self).add_to_parser(parser, ctx)  # noqa: UP008 false positive\n    for name in self.opts:\n        our_parser = parser._long_opt.get(name) or parser._short_opt.get(name)\n        if our_parser:\n            self._eat_all_parser = our_parser\n            self._previous_parser_process = our_parser.process\n            our_parser.process = parser_process\n            break\n\n    return retval\n</code></pre>"},{"location":"reference/variantplaner/cli/#variantplaner.cli.main","title":"main","text":"<pre><code>main(\n    ctx: Context,\n    *,\n    threads: int = 1,\n    verbose: int = 0,\n    debug_info: bool = False\n) -&gt; None\n</code></pre> <p>Run VariantPlanner.</p> Source code in <code>src/variantplaner/cli/__init__.py</code> <pre><code>@click.group(name=\"variantplaner\", context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\n@click.pass_context\n@click.option(\n    \"-t\",\n    \"--threads\",\n    help=\"Number of threads usable\",\n    default=1,\n    type=click.IntRange(0),\n    show_default=True,\n)\n@click.option(\"-v\", \"--verbose\", help=\"Verbosity level\", count=True, type=click.IntRange(0, 4))\n@click.option(\n    \"--debug-info\",\n    help=\"Get debug information\",\n    is_flag=True,\n    show_default=True,\n    default=False,\n)\ndef main(ctx: click.Context, *, threads: int = 1, verbose: int = 0, debug_info: bool = False) -&gt; None:\n    \"\"\"Run VariantPlanner.\"\"\"\n    logging.basicConfig(\n        style=\"{\",\n        format=\"{asctime} - {name}:{levelname}: {message}\",\n        encoding=\"utf-8\",\n        level=(4 - verbose) * 10,  # Python choose a strange logging levels order\n        stream=sys.stderr,\n    )\n\n    logger = logging.getLogger(\"main\")\n\n    logger.debug(f\"parameter: {threads=} {verbose=} {debug_info=}\")\n\n    if debug_info:\n        debug.print_info()\n        sys.exit(0)\n\n    ctx.obj = {\n        \"threads\": threads,\n    }\n\n    polars.set_random_seed(42)\n    os.environ[\"POLARS_MAX_THREADS\"] = str(threads)\n</code></pre>"},{"location":"reference/variantplaner/cli/metadata/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> metadata","text":""},{"location":"reference/variantplaner/cli/metadata/#variantplaner.cli.metadata","title":"metadata","text":"<p>Module contains command line entry point function.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Module contains command line entry point function.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>metadata</code>             \u2013              <p>Convert metadata file in parquet file.</p> </li> </ul>"},{"location":"reference/variantplaner/cli/metadata/#variantplaner.cli.metadata.metadata","title":"metadata","text":"<pre><code>metadata(\n    input_path: Path, output_path: Path, input_type: str\n) -&gt; None\n</code></pre> <p>Convert metadata file in parquet file.</p> Source code in <code>src/variantplaner/cli/metadata.py</code> <pre><code>@cli.main.command(name=\"metadata\")  # type: ignore[has-type]\n@click.option(\n    \"-i\",\n    \"--input-path\",\n    help=\"Input path.\",\n    type=click.Path(exists=True, readable=True, allow_dash=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-o\",\n    \"--output-path\",\n    help=\"Output path.\",\n    type=click.Path(writable=True, allow_dash=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-t\",\n    \"--input-type\",\n    help=\"Type of input file.\",\n    type=click.Choice([\"csv\", \"tsv\", \"ljson\", \"json\"]),\n    required=True,\n)\ndef metadata(\n    input_path: pathlib.Path,\n    output_path: pathlib.Path,\n    input_type: str,\n) -&gt; None:\n    \"\"\"Convert metadata file in parquet file.\"\"\"\n    logger = logging.getLogger(\"metadata\")\n\n    logger.debug(f\"parameter: {input_path=} {output_path=} {input_type=}\")\n\n    if input_type == \"csv\":\n        lf = polars.scan_csv(input_path)\n        lf.sink_parquet(output_path, maintain_order=False)\n    elif input_type == \"tsv\":\n        lf = polars.scan_csv(input_path, separator=\"\\t\")\n        lf.sink_parquet(output_path, maintain_order=False)\n    elif input_type == \"ljson\":\n        df = polars.read_ndjson(input_path)\n        df.write_parquet(output_path)\n    else:\n        df = polars.read_json(input_path)\n\n        df.write_parquet(output_path)\n</code></pre>"},{"location":"reference/variantplaner/cli/parquet2vcf/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> parquet2vcf","text":""},{"location":"reference/variantplaner/cli/parquet2vcf/#variantplaner.cli.parquet2vcf","title":"parquet2vcf","text":"<p>Module contains parquet2vcf subcommand entry point function.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Module contains command line entry point function.</p> </li> <li> <code>io</code>           \u2013            <p>Module manage input parsing and output serializing.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>parquet2vcf</code>             \u2013              <p>Convert variant parquet in vcf.</p> </li> </ul>"},{"location":"reference/variantplaner/cli/parquet2vcf/#variantplaner.cli.parquet2vcf.parquet2vcf","title":"parquet2vcf","text":"<pre><code>parquet2vcf(\n    variants_path: Path,\n    output_path: Path,\n    genotypes_path: Path | None = None,\n    headers_path: Path | None = None,\n    select_chromosome: str | None = None,\n    chromosome: str = \"chr\",\n    position: str = \"pos\",\n    identifier: str = \"id\",\n    reference: str = \"ref\",\n    alternative: str = \"alt\",\n    quality: str | None = None,\n    filter_col: str | None = None,\n    format_str: str | None = None,\n) -&gt; None\n</code></pre> <p>Convert variant parquet in vcf.</p> Source code in <code>src/variantplaner/cli/parquet2vcf.py</code> <pre><code>@cli.main.command(\"parquet2vcf\")  # type: ignore[has-type]\n@click.option(\n    \"-v\",\n    \"--variants-path\",\n    help=\"Path to variant parquet.\",\n    type=click.Path(\n        exists=True,\n        dir_okay=False,\n        readable=True,\n        allow_dash=True,\n        path_type=pathlib.Path,\n    ),\n    required=True,\n)\n@click.option(\n    \"-o\",\n    \"--output-path\",\n    help=\"Path where the vcf is written.\",\n    type=click.Path(dir_okay=False, writable=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-g\",\n    \"--genotypes-path\",\n    help=\"Path to genotype parquet.\",\n    type=click.Path(\n        exists=True,\n        dir_okay=False,\n        readable=True,\n        allow_dash=True,\n        path_type=pathlib.Path,\n    ),\n)\n@click.option(\n    \"-H\",\n    \"--headers-path\",\n    help=\"Path to vcf header.\",\n    type=click.Path(\n        exists=True,\n        dir_okay=False,\n        readable=True,\n        allow_dash=True,\n        path_type=pathlib.Path,\n    ),\n)\n@click.option(\n    \"-s\",\n    \"--select-chromosome\",\n    help=\"Output only record where chromosome match target\",\n    type=str,\n)\n@click.option(\n    \"-c\",\n    \"--chromosome\",\n    help=\"Name of chromosome column.\",\n    type=str,\n    default=\"chr\",\n    show_default=True,\n)\n@click.option(\n    \"-p\",\n    \"--position\",\n    help=\"Name of position column.\",\n    type=str,\n    default=\"pos\",\n    show_default=True,\n)\n@click.option(\n    \"-I\",\n    \"--identifier\",\n    help=\"Name of identity column.\",\n    type=str,\n    default=\"id\",\n    show_default=True,\n)\n@click.option(\n    \"-r\",\n    \"--reference\",\n    help=\"Name of reference column.\",\n    default=\"ref\",\n    show_default=True,\n)\n@click.option(\n    \"-a\",\n    \"--alternative\",\n    help=\"Name of alternative column.\",\n    default=\"alt\",\n    show_default=True,\n)\n@click.option(\n    \"-q\",\n    \"--quality\",\n    help=\"Name of quality column.\",\n    type=str,\n)\n@click.option(\n    \"-f\",\n    \"--filter\",\n    \"filter_col\",\n    help=\"Name of filter column.\",\n    type=str,\n)\n@click.option(\n    \"-F\",\n    \"--format\",\n    \"format_str\",\n    help=\"Value of format column.\",\n    type=str,\n)\ndef parquet2vcf(\n    variants_path: pathlib.Path,\n    output_path: pathlib.Path,\n    genotypes_path: pathlib.Path | None = None,\n    headers_path: pathlib.Path | None = None,\n    select_chromosome: str | None = None,\n    chromosome: str = \"chr\",\n    position: str = \"pos\",\n    identifier: str = \"id\",\n    reference: str = \"ref\",\n    alternative: str = \"alt\",\n    quality: str | None = None,\n    filter_col: str | None = None,\n    format_str: str | None = None,\n) -&gt; None:\n    \"\"\"Convert variant parquet in vcf.\"\"\"\n    logger = logging.getLogger(\"vcf2parquet\")\n\n    logger.debug(\n        f\"parameter: {variants_path} {output_path} {genotypes_path} {headers_path} {chromosome} {position} {identifier} {reference} {alternative} {quality} {filter_col} {format_str}\"\n    )\n\n    vcf = Vcf()\n\n    lf = polars.scan_parquet(variants_path)\n    if select_chromosome is not None:\n        lf = lf.filter(polars.col(chromosome) == select_chromosome)\n\n    vcf.set_variants(Variants(lf))\n\n    if headers_path:\n        vcf.header.from_files(headers_path)\n    else:\n        headers = None\n\n    if genotypes_path and format_str:\n        genotypes = Genotypes(polars.scan_parquet(genotypes_path))\n        vcf.add_genotypes(genotypes)\n\n        sample2vcf_col2polars_col: dict[str, dict[str, str]] = {}\n        for sample in genotypes.samples_names():\n            sample2vcf_col2polars_col[sample] = {}\n            for format_col in format_str.split(\":\"):\n                sample2vcf_col2polars_col[sample][format_col] = f\"{sample}_{format_col.lower()}\"\n        rename_column = io.vcf.build_rename_column(\n            chromosome,\n            position,\n            identifier,\n            reference,\n            alternative,\n            quality,\n            filter_col,\n            [],\n            format_str,\n            sample2vcf_col2polars_col,\n        )\n    else:\n        rename_column = io.vcf.build_rename_column(\n            chromosome,\n            position,\n            identifier,\n            reference,\n            alternative,\n            quality,\n            filter_col,\n        )\n\n    io.vcf.lazyframe_in_vcf(\n        vcf.lf,\n        output_path,\n        vcf_header=headers,\n        renaming=rename_column,\n    )\n</code></pre>"},{"location":"reference/variantplaner/cli/struct/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> struct","text":""},{"location":"reference/variantplaner/cli/struct/#variantplaner.cli.struct","title":"struct","text":"<p>Module contains struct subcommand entry point function.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Module contains command line entry point function.</p> </li> <li> <code>vp_struct</code>           \u2013            <p>Generated data structures for easy integration.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>genotypes</code>             \u2013              <p>Convert set of genotype parquet in hive like files structures.</p> </li> <li> <code>struct</code>             \u2013              <p>Subcommand to made struct operation on parquet file.</p> </li> <li> <code>variants</code>             \u2013              <p>Merge multiple variants parquet file in one.</p> </li> </ul>"},{"location":"reference/variantplaner/cli/struct/#variantplaner.cli.struct.genotypes","title":"genotypes","text":"<pre><code>genotypes(\n    ctx: Context,\n    prefix_path: Path,\n    partition_mode: str,\n    number_of_part: int,\n    file_per_thread: int,\n    polars_threads: int,\n) -&gt; None\n</code></pre> <p>Convert set of genotype parquet in hive like files structures.</p> Source code in <code>src/variantplaner/cli/struct.py</code> <pre><code>@struct.command(\"genotypes\")\n@click.pass_context\n@click.option(\n    \"-p\",\n    \"--prefix-path\",\n    help=\"Prefix add before genotype partitions\",\n    type=click.Path(file_okay=False, dir_okay=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-m\",\n    \"--partition-mode\",\n    help=\"Partition mode\",\n    type=click.Choice([\"random\", \"position\"]),\n    default=\"position\",\n    show_default=True,\n)\n@click.option(\n    \"-n\",\n    \"--number-of-part\",\n    help=\"Maximal number of part, automaticly correct to next power of two\",\n    type=click.IntRange(min=1),\n    default=256,\n    show_default=True,\n)\n@click.option(\n    \"-f\",\n    \"--file-per-thread\",\n    help=\"Number of file manage by on threads, reduce value to reduce memory usage\",\n    type=click.IntRange(min=1),\n    default=15,\n    show_default=True,\n)\n@click.option(\n    \"-P\",\n    \"--polars-threads\",\n    help=\"Number of threads use by polars task\",\n    type=click.IntRange(1),\n    default=4,\n    show_default=True,\n)\ndef genotypes(\n    ctx: click.Context,\n    prefix_path: pathlib.Path,\n    partition_mode: str,\n    number_of_part: int,\n    file_per_thread: int,\n    polars_threads: int,\n) -&gt; None:\n    \"\"\"Convert set of genotype parquet in hive like files structures.\"\"\"\n    logger = logging.getLogger(\"struct.genotypes\")\n\n    ctx.ensure_object(dict)\n\n    input_paths = ctx.obj[\"input_paths\"]\n    threads = ctx.obj[\"threads\"]\n    append = ctx.obj[\"append\"]\n\n    os.environ[\"POLARS_MAX_THREADS\"] = str(polars_threads)\n\n    logger.debug(f\"parameter: {prefix_path=} {partition_mode=} {number_of_part=} {file_per_thread=} {polars_threads=}\")\n\n    number_of_bits = math.ceil(math.log2(number_of_part))\n\n    vp_struct.genotypes.hive(\n        input_paths, prefix_path, threads, file_per_thread, append=append, number_of_bits=number_of_bits\n    )\n</code></pre>"},{"location":"reference/variantplaner/cli/struct/#variantplaner.cli.struct.struct","title":"struct","text":"<pre><code>struct(\n    ctx: Context, input_paths: list[Path], *, append: bool\n) -&gt; None\n</code></pre> <p>Subcommand to made struct operation on parquet file.</p> Source code in <code>src/variantplaner/cli/struct.py</code> <pre><code>@cli.main.group(\"struct\", chain=True)  # type: ignore[has-type]\n@click.pass_context\n@click.option(\n    \"-i\",\n    \"--input-paths\",\n    help=\"Paths of the variant files to be merged.\",\n    cls=cli.MultipleValueOption,\n    type=click.Path(exists=True, dir_okay=False, readable=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-a\",\n    \"--append\",\n    help=\"Switch in append mode.\",\n    type=bool,\n    is_flag=True,\n)\ndef struct(ctx: click.Context, input_paths: list[pathlib.Path], *, append: bool) -&gt; None:\n    \"\"\"Subcommand to made struct operation on parquet file.\"\"\"\n    logger = logging.getLogger(\"struct\")\n\n    if not (isinstance(input_paths, (list, tuple))):\n        input_paths = [input_paths]\n\n    ctx.obj[\"input_paths\"] = input_paths\n    ctx.obj[\"append\"] = append\n\n    logger.debug(f\"parameter: {input_paths=} {append=}\")\n</code></pre>"},{"location":"reference/variantplaner/cli/struct/#variantplaner.cli.struct.variants","title":"variants","text":"<pre><code>variants(\n    ctx: Context,\n    output_prefix: Path,\n    chunk_size: int,\n    polars_threads: int,\n) -&gt; None\n</code></pre> <p>Merge multiple variants parquet file in one.</p> <p>If you set TMPDIR, TEMP or TMP environment variable you can control where temp file is created.</p> Source code in <code>src/variantplaner/cli/struct.py</code> <pre><code>@struct.command(\"variants\")\n@click.pass_context\n@click.option(\n    \"-o\",\n    \"--output-prefix\",\n    help=\"Prefix added before file where unique variants will be written.\",\n    type=click.Path(writable=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-c\",\n    \"--chunk-size\",\n    help=\"Sizes of files chunks that will be grouped together to build the list of unique variants\",\n    type=click.IntRange(min=1),\n    default=1_000_000,\n    show_default=True,\n)\n@click.option(\n    \"-p\",\n    \"--polars-threads\",\n    help=\"Number of threads use to merge each chunk of files.\",\n    type=click.IntRange(min=1),\n    default=4,\n    show_default=True,\n)\ndef variants(\n    ctx: click.Context,\n    output_prefix: pathlib.Path,\n    chunk_size: int,\n    polars_threads: int,\n) -&gt; None:\n    \"\"\"Merge multiple variants parquet file in one.\n\n    If you set TMPDIR, TEMP or TMP environment variable you can control where temp file is created.\n    \"\"\"\n    logger = logging.getLogger(\"struct.variants\")\n\n    ctx.ensure_object(dict)\n\n    input_paths = ctx.obj[\"input_paths\"]\n    append = ctx.obj[\"append\"]\n\n    logger.debug(f\"parameter: {output_prefix=} {chunk_size=}\")\n\n    vp_struct.variants.merge(input_paths, output_prefix, chunk_size, polars_threads, append=append)\n</code></pre>"},{"location":"reference/variantplaner/cli/transmission/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> transmission","text":""},{"location":"reference/variantplaner/cli/transmission/#variantplaner.cli.transmission","title":"transmission","text":"<p>Module contains transmission subcommand entry point function.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Module contains command line entry point function.</p> </li> <li> <code>generate</code>           \u2013            <p>Function to generate information.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>transmission</code>             \u2013              <p>Generate transmission of a genotype set.</p> </li> </ul>"},{"location":"reference/variantplaner/cli/transmission/#variantplaner.cli.transmission.transmission","title":"transmission","text":"<pre><code>transmission(\n    genotypes_path: Path,\n    output_path: Path,\n    pedigree_path: Path | None,\n    index: str | None,\n    mother: str | None,\n    father: str | None,\n) -&gt; None\n</code></pre> <p>Generate transmission of a genotype set.</p> Source code in <code>src/variantplaner/cli/transmission.py</code> <pre><code>@cli.main.command(\"transmission\")  # type: ignore[has-type]\n@click.option(\n    \"-g\",\n    \"--genotypes-path\",\n    help=\"Path to genotypes parquet.\",\n    type=click.Path(exists=True, readable=True, allow_dash=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-p\",\n    \"--pedigree-path\",\n    help=\"Path to pedigree file.\",\n    type=click.Path(exists=True, readable=True, path_type=pathlib.Path),\n)\n@click.option(\n    \"-i\",\n    \"--index\",\n    help=\"Sample name of index.\",\n    type=str,\n)\n@click.option(\n    \"-m\",\n    \"--mother\",\n    help=\"Sample name of mother.\",\n    type=str,\n)\n@click.option(\n    \"-f\",\n    \"--father\",\n    help=\"Sample name of father.\",\n    type=str,\n)\n@click.option(\n    \"-o\",\n    \"--output-path\",\n    help=\"Path where transmission will be write.\",\n    type=click.Path(writable=True, path_type=pathlib.Path),\n)\ndef transmission(\n    genotypes_path: pathlib.Path,\n    output_path: pathlib.Path,\n    pedigree_path: pathlib.Path | None,\n    index: str | None,\n    mother: str | None,\n    father: str | None,\n) -&gt; None:\n    \"\"\"Generate transmission of a genotype set.\"\"\"\n    logger = logging.getLogger(\"vcf2parquet.genotypes\")\n\n    logger.debug(f\"parameter: {genotypes_path=} {output_path=} {pedigree_path=} {index=} {mother=} {father=}\")\n\n    genotypes_lf = polars.scan_parquet(genotypes_path)\n\n    if pedigree_path:\n        pedigree = Pedigree()\n        pedigree.from_path(pedigree_path)\n        transmission_lf = generate.transmission_ped(genotypes_lf, pedigree.lf)\n    elif index:\n        transmission_lf = generate.transmission(genotypes_lf, index, mother, father)\n    else:\n        logging.error(\"You must specify ped file or index almost sample name\")\n        sys.exit(31)\n\n    transmission_lf.write_parquet(output_path)\n</code></pre>"},{"location":"reference/variantplaner/cli/vcf2parquet/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> vcf2parquet","text":""},{"location":"reference/variantplaner/cli/vcf2parquet/#variantplaner.cli.vcf2parquet","title":"vcf2parquet","text":"<p>Module contains vcf2parquet subcommand entry point function.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Module contains command line entry point function.</p> </li> <li> <code>exception</code>           \u2013            <p>Exception could be generate by VariantPlanner.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>annotations_subcommand</code>             \u2013              <p>Write annotations.</p> </li> <li> <code>genotypes</code>             \u2013              <p>Write genotypes.</p> </li> <li> <code>headers</code>             \u2013              <p>Write vcf headers.</p> </li> <li> <code>variants</code>             \u2013              <p>Write variants.</p> </li> <li> <code>vcf2parquet</code>             \u2013              <p>Convert a vcf in parquet.</p> </li> </ul>"},{"location":"reference/variantplaner/cli/vcf2parquet/#variantplaner.cli.vcf2parquet.annotations_subcommand","title":"annotations_subcommand","text":"<pre><code>annotations_subcommand(\n    ctx: Context,\n    output_path: Path,\n    info: set[str] | None = None,\n    rename_id: str | None = None,\n) -&gt; None\n</code></pre> <p>Write annotations.</p> Source code in <code>src/variantplaner/cli/vcf2parquet.py</code> <pre><code>@vcf2parquet.command(\"annotations\")\n@click.pass_context\n@click.option(\n    \"-o\",\n    \"--output-path\",\n    help=\"Path where genotypes will be written.\",\n    type=click.Path(writable=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-i\",\n    \"--info\",\n    help=\"List of info fields that are kept if this list is empty all fields are kept only the first vcf file header is read.\",\n    cls=cli.MultipleValueOption,\n    type=str,\n)\n@click.option(\n    \"-r\",\n    \"--rename-id\",\n    help=\"Set column name of variant id.\",\n    type=str,\n)\ndef annotations_subcommand(\n    ctx: click.Context,\n    output_path: pathlib.Path,\n    info: set[str] | None = None,\n    rename_id: str | None = None,\n) -&gt; None:\n    \"\"\"Write annotations.\"\"\"\n    logger = logging.getLogger(\"vcf2parquet.annotations\")\n\n    lf = ctx.obj[\"lazyframe\"]\n    append = ctx.obj[\"append\"]\n    headers_obj = ctx.obj[\"headers\"]\n\n    logger.debug(f\"parameter: {output_path=}\")\n\n    logger.info(\"Start extract annotations\")\n    annotations_data = lf.lf.with_columns(headers_obj.info_parser(info))\n    annotations_data = annotations_data.drop([\"chr\", \"pos\", \"ref\", \"alt\", \"filter\", \"qual\", \"info\"])\n\n    if rename_id:\n        logger.info(f\"Rename vcf variant id in {rename_id}\")\n        annotations_data = annotations_data.rename({\"vid\": rename_id})\n    logger.info(\"End extract annotations\")\n\n    if append:\n        annotations_data = __append(output_path, annotations_data)\n\n    logger.info(f\"Start write annotations in {output_path}\")\n    try:\n        annotations_data.sink_parquet(output_path, maintain_order=False)\n    except polars.exceptions.InvalidOperationError:\n        annotations_data.collect(streaming=True).write_parquet(output_path)\n    logger.info(f\"End write annotations in {output_path}\")\n</code></pre>"},{"location":"reference/variantplaner/cli/vcf2parquet/#variantplaner.cli.vcf2parquet.genotypes","title":"genotypes","text":"<pre><code>genotypes(\n    ctx: Context,\n    output_path: Path,\n    format_string: str = \"GT:AD:DP:GQ\",\n) -&gt; None\n</code></pre> <p>Write genotypes.</p> Source code in <code>src/variantplaner/cli/vcf2parquet.py</code> <pre><code>@vcf2parquet.command(\"genotypes\")\n@click.pass_context\n@click.option(\n    \"-o\",\n    \"--output-path\",\n    help=\"Path where genotypes will be written.\",\n    type=click.Path(writable=True, path_type=pathlib.Path),\n    required=True,\n)\n@click.option(\n    \"-f\",\n    \"--format-string\",\n    help=\"Value of FORMAT column, line not match with this are ignored.\",\n    type=str,\n    default=\"GT:AD:DP:GQ\",\n    show_default=True,\n)\ndef genotypes(\n    ctx: click.Context,\n    output_path: pathlib.Path,\n    format_string: str = \"GT:AD:DP:GQ\",\n) -&gt; None:\n    \"\"\"Write genotypes.\"\"\"\n    logger = logging.getLogger(\"vcf2parquet.genotypes\")\n\n    lf = ctx.obj[\"lazyframe\"]\n    append = ctx.obj[\"append\"]\n\n    logger.debug(f\"parameter: {output_path=} {format_string=}\")\n\n    try:\n        genotypes_data = lf.genotypes(format_string)\n    except exception.NoGenotypeError:\n        logger.error(\"It's seems vcf not contains genotypes information.\")  # noqa: TRY400  we are in cli exception isn't readable\n        sys.exit(12)\n\n    if append:\n        genotypes_data = __append(output_path, genotypes_data)\n\n    logger.info(f\"Start write genotypes in {output_path}\")\n    try:\n        genotypes_data.lf.sink_parquet(output_path, maintain_order=False)\n    except polars.exceptions.InvalidOperationError:\n        genotypes_data.lf.collect(streaming=True).write_parquet(output_path)\n    logger.info(f\"End write genotypes in {output_path}\")\n</code></pre>"},{"location":"reference/variantplaner/cli/vcf2parquet/#variantplaner.cli.vcf2parquet.headers","title":"headers","text":"<pre><code>headers(ctx: Context, output_path: Path) -&gt; None\n</code></pre> <p>Write vcf headers.</p> Source code in <code>src/variantplaner/cli/vcf2parquet.py</code> <pre><code>@vcf2parquet.command(\"headers\")\n@click.pass_context\n@click.option(\n    \"-o\",\n    \"--output-path\",\n    help=\"Path where header will be written.\",\n    type=click.Path(writable=True, path_type=pathlib.Path),\n    required=True,\n)\ndef headers(\n    ctx: click.Context,\n    output_path: pathlib.Path,\n) -&gt; None:\n    \"\"\"Write vcf headers.\"\"\"\n    logger = logging.getLogger(\"vcf2parquet.headers\")\n\n    headers_obj = ctx.obj[\"headers\"]\n\n    logger.debug(f\"parameter: {output_path=}\")\n\n    logger.info(f\"Start write headers in {output_path}\")\n    with open(output_path, \"w\") as fh_out:\n        for line in headers_obj:\n            print(line, file=fh_out)\n    logger.info(f\"End write headers in {output_path}\")\n</code></pre>"},{"location":"reference/variantplaner/cli/vcf2parquet/#variantplaner.cli.vcf2parquet.variants","title":"variants","text":"<pre><code>variants(ctx: Context, output_path: Path) -&gt; None\n</code></pre> <p>Write variants.</p> Source code in <code>src/variantplaner/cli/vcf2parquet.py</code> <pre><code>@vcf2parquet.command(\"variants\")\n@click.pass_context\n@click.option(\n    \"-o\",\n    \"--output-path\",\n    help=\"Path where variants will be written.\",\n    type=click.Path(writable=True, path_type=pathlib.Path),\n    required=True,\n)\ndef variants(\n    ctx: click.Context,\n    output_path: pathlib.Path,\n) -&gt; None:\n    \"\"\"Write variants.\"\"\"\n    logger = logging.getLogger(\"vcf2parquet.variants\")\n\n    lf = ctx.obj[\"lazyframe\"]\n    append = ctx.obj[\"append\"]\n\n    logger.debug(f\"parameter: {output_path=}\")\n\n    logger.info(f\"Start write variants in {output_path}\")\n    variants = lf.variants()\n\n    if append:\n        variants = __append(output_path, variants)\n\n    try:\n        variants.sink_parquet(output_path, maintain_order=False)\n    except polars.exceptions.InvalidOperationError:\n        variants.collect(streaming=True).write_parquet(output_path)\n    logger.info(f\"End write variants in {output_path}\")\n</code></pre>"},{"location":"reference/variantplaner/cli/vcf2parquet/#variantplaner.cli.vcf2parquet.vcf2parquet","title":"vcf2parquet","text":"<pre><code>vcf2parquet(\n    ctx: Context,\n    input_path: Path,\n    chrom2length_path: Path | None,\n    *,\n    append: bool\n) -&gt; None\n</code></pre> <p>Convert a vcf in parquet.</p> Source code in <code>src/variantplaner/cli/vcf2parquet.py</code> <pre><code>@cli.main.group(\"vcf2parquet\", chain=True)  # type: ignore[has-type]\n@click.pass_context\n@click.option(\n    \"-i\",\n    \"--input-path\",\n    help=\"Path to vcf input file.\",\n    type=click.Path(\n        exists=True,\n        dir_okay=False,\n        readable=True,\n        allow_dash=True,\n        path_type=pathlib.Path,\n    ),\n    required=True,\n)\n@click.option(\n    \"-c\",\n    \"--chrom2length-path\",\n    help=\"CSV file that associates a chromosome name with its size.\",\n    type=click.Path(dir_okay=False, writable=True, path_type=pathlib.Path),\n)\n@click.option(\n    \"-a\",\n    \"--append\",\n    help=\"Switch in append mode.\",\n    type=bool,\n    is_flag=True,\n)\ndef vcf2parquet(\n    ctx: click.Context,\n    input_path: pathlib.Path,\n    chrom2length_path: pathlib.Path | None,\n    *,\n    append: bool,\n) -&gt; None:\n    \"\"\"Convert a vcf in parquet.\"\"\"\n    logger = logging.getLogger(\"vcf2parquet\")\n\n    logger.debug(f\"parameter: {input_path=} {chrom2length_path=} {append=}\")\n\n    lf = Vcf()\n\n    # Read vcf and manage structural variant\n    logger.debug(\"Start read vcf\")\n    try:\n        lf.from_path(input_path, chrom2length_path, behavior=VcfParsingBehavior.MANAGE_SV)\n    except exception.NotVcfHeaderError:\n        logging.error(f\"Path {input_path} seems not contains Vcf.\")  # noqa: TRY400  we are in cli exception isn't readable\n        sys.exit(11)\n    except exception.NotAVCFError:\n        logging.error(f\"Path {input_path} seems not contains Vcf.\")  # noqa: TRY400  we are in cli exception isn't readable\n        sys.exit(12)\n    except exception.NoContigsLengthInformationError:\n        logging.error(\"Vcf didn't contains contigs length information you could use chrom2length-path argument.\")  # noqa: TRY400  we are in cli exception isn't readable\n        sys.exit(13)\n    logger.debug(\"End read vcf\")\n\n    ctx.obj[\"vcf_path\"] = input_path\n    ctx.obj[\"lazyframe\"] = lf\n    ctx.obj[\"append\"] = append\n    ctx.obj[\"headers\"] = lf.header\n</code></pre>"},{"location":"reference/variantplaner/io/","title":"Index","text":""},{"location":"reference/variantplaner/io/#variantplaner.io","title":"io","text":"<p>Module manage input parsing and output serializing.</p> <p>Modules:</p> <ul> <li> <code>vcf</code>           \u2013            <p>Read and write vcf file.</p> </li> </ul>"},{"location":"reference/variantplaner/io/vcf/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> vcf","text":""},{"location":"reference/variantplaner/io/vcf/#variantplaner.io.vcf","title":"vcf","text":"<p>Read and write vcf file.</p> <p>Functions:</p> <ul> <li> <code>build_rename_column</code>             \u2013              <p>A helper function to generate rename column dict for variantplaner.io.vcf.lazyframe_in_vcf function parameter.</p> </li> <li> <code>lazyframe_in_vcf</code>             \u2013              <p>Write polars.LazyFrame in vcf format.</p> </li> </ul>"},{"location":"reference/variantplaner/io/vcf/#variantplaner.io.vcf.build_rename_column","title":"build_rename_column","text":"<pre><code>build_rename_column(\n    chromosome: str,\n    pos: str,\n    identifier: str,\n    ref: str,\n    alt: str,\n    qual: str | None = \".\",\n    filter_col: str | None = \".\",\n    info: list[tuple[str, str]] | None = None,\n    format_string: str | None = None,\n    sample: dict[str, dict[str, str]] | None = None,\n) -&gt; RenameCol\n</code></pre> <p>A helper function to generate rename column dict for variantplaner.io.vcf.lazyframe_in_vcf function parameter.</p> <p>Returns:</p> <ul> <li> <code>RenameCol</code>           \u2013            <p>A rename column dictionary.</p> </li> </ul> Source code in <code>src/variantplaner/io/vcf.py</code> <pre><code>def build_rename_column(\n    chromosome: str,\n    pos: str,\n    identifier: str,\n    ref: str,\n    alt: str,\n    qual: str | None = \".\",\n    filter_col: str | None = \".\",\n    info: list[tuple[str, str]] | None = None,\n    format_string: str | None = None,\n    sample: dict[str, dict[str, str]] | None = None,\n) -&gt; RenameCol:\n    \"\"\"A helper function to generate rename column dict for [variantplaner.io.vcf.lazyframe_in_vcf][] function parameter.\n\n    Returns:\n        A rename column dictionary.\n    \"\"\"\n    return {\n        \"#CHROM\": chromosome,\n        \"POS\": pos,\n        \"ID\": identifier,\n        \"REF\": ref,\n        \"ALT\": alt,\n        \"QUAL\": \".\" if qual is None else qual,\n        \"FILTER\": \".\" if filter_col is None else filter_col,\n        \"INFO\": [] if info is None else info,\n        \"FORMAT\": \"\" if format_string is None else format_string,\n        \"sample\": {} if sample is None else sample,\n    }\n</code></pre>"},{"location":"reference/variantplaner/io/vcf/#variantplaner.io.vcf.lazyframe_in_vcf","title":"lazyframe_in_vcf","text":"<pre><code>lazyframe_in_vcf(\n    lf: LazyFrame,\n    output_path: Path,\n    /,\n    vcf_header: VcfHeader | None = None,\n    renaming: RenameCol = DEFAULT_RENAME,\n) -&gt; None\n</code></pre> <p>Write polars.LazyFrame in vcf format.</p> <p>Warning: This function performs polars.LazyFrame.collect before write vcf, this can have a significant impact on memory usage.</p> <p>Parameters:</p> <ul> <li> <code>lf</code>               (<code>LazyFrame</code>)           \u2013            <p>LazyFrame contains information.</p> </li> <li> <code>output_path</code>               (<code>Path</code>)           \u2013            <p>Path to where vcf to write.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/variantplaner/io/vcf.py</code> <pre><code>def lazyframe_in_vcf(\n    lf: polars.LazyFrame,\n    output_path: pathlib.Path,\n    /,\n    vcf_header: VcfHeader | None = None,\n    renaming: RenameCol = DEFAULT_RENAME,\n) -&gt; None:\n    \"\"\"Write [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) in vcf format.\n\n    Warning: This function performs [polars.LazyFrame.collect][] before write vcf, this can have a significant impact on memory usage.\n\n    Args:\n        lf: LazyFrame contains information.\n        output_path: Path to where vcf to write.\n\n    Returns:\n        None\n    \"\"\"\n    select_column: list[str] = []\n\n    lf = lf.with_columns(\n        [\n            polars.col(renaming[\"#CHROM\"]).alias(\"#CHROM\"),\n            polars.col(renaming[\"POS\"]).alias(\"POS\"),\n            polars.col(renaming[\"ID\"]).alias(\"ID\"),\n            polars.col(renaming[\"REF\"]).alias(\"REF\"),\n            polars.col(renaming[\"ALT\"]).alias(\"ALT\"),\n        ],\n    )\n\n    select_column.extend([\"#CHROM\", \"POS\", \"ID\", \"REF\", \"ALT\"])\n\n    if vcf_header is None:\n        header = __generate_header(lf, renaming[\"INFO\"], list(renaming[\"sample\"].keys()), renaming[\"FORMAT\"])\n    else:\n        header = \"\\n\".join(vcf_header._header)\n\n    if renaming[\"QUAL\"] != \".\":\n        lf = lf.with_columns([polars.col(renaming[\"QUAL\"]).alias(\"QUAL\")])\n    else:\n        lf = lf.with_columns([polars.lit(\".\").alias(\"QUAL\")])\n\n    select_column.append(\"QUAL\")\n\n    if renaming[\"FILTER\"] != \".\":\n        lf = lf.with_columns([polars.col(renaming[\"FILTER\"]).alias(\"FILTER\")])\n    else:\n        lf = lf.with_columns([polars.lit(\".\").alias(\"FILTER\")])\n\n    select_column.append(\"FILTER\")\n\n    lf = (\n        __rebuild_info_column(lf, renaming[\"INFO\"])\n        if renaming[\"INFO\"]\n        else lf.with_columns(polars.lit(\".\").alias(\"INFO\"))\n    )\n\n    select_column.append(\"INFO\")\n\n    if renaming[\"FORMAT\"]:\n        lf = lf.with_columns(polars.lit(renaming[\"FORMAT\"]).alias(\"FORMAT\"))\n        select_column.append(\"FORMAT\")\n\n    if renaming[\"FORMAT\"] and renaming[\"sample\"]:\n        schema = lf.collect_schema()\n        for sample_name in renaming[\"sample\"]:\n            lf = lf.with_columns(\n                [\n                    __lazy2format(\n                        sample_name,\n                        renaming[\"FORMAT\"],\n                        dict(zip(schema.names(), schema.dtypes())),\n                    ).alias(sample_name),\n                ],\n            )\n            select_column.append(sample_name)\n\n    lf = lf.select([polars.col(col) for col in select_column])\n\n    with open(output_path, \"wb\") as fh:\n        fh.write(header.encode())\n        fh.write(lf.collect().write_csv(separator=\"\\t\").encode())\n</code></pre>"},{"location":"reference/variantplaner/objects/","title":"Index","text":""},{"location":"reference/variantplaner/objects/#variantplaner.objects","title":"objects","text":"<p>Module to store variantplaner object.</p> <p>Modules:</p> <ul> <li> <code>annotations</code>           \u2013            <p>Declare Genotypes object.</p> </li> <li> <code>contigs_length</code>           \u2013            <p>Declare Vcf object.</p> </li> <li> <code>csv</code>           \u2013            <p>Declare CSV object.</p> </li> <li> <code>genotypes</code>           \u2013            <p>Declare Genotypes object.</p> </li> <li> <code>pedigree</code>           \u2013            <p>Declare Pedigree object.</p> </li> <li> <code>variants</code>           \u2013            <p>Declare Variants object.</p> </li> <li> <code>vcf</code>           \u2013            <p>Declare Vcf object.</p> </li> <li> <code>vcf_header</code>           \u2013            <p>Declare Vcf object.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Annotations</code>           \u2013            <p>Object to manage lazyframe as Annotations.</p> </li> <li> <code>ContigsLength</code>           \u2013            <p>Store contigs -&gt; length information.</p> </li> <li> <code>Genotypes</code>           \u2013            <p>Object to manage lazyframe as Genotypes.</p> </li> <li> <code>Pedigree</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> <li> <code>Variants</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> <li> <code>Vcf</code>           \u2013            <p>Object to manage lazyframe as Vcf.</p> </li> <li> <code>VcfHeader</code>           \u2013            <p>Object that parse and store vcf information.</p> </li> <li> <code>VcfParsingBehavior</code>           \u2013            <p>Enumeration use to control behavior of IntoLazyFrame.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Annotations","title":"Annotations","text":"<pre><code>Annotations()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Annotations.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Annotations object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Annotations.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Annotations.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.ContigsLength","title":"ContigsLength","text":"<pre><code>ContigsLength()\n</code></pre> <p>Store contigs -&gt; length information.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Fill object with file point by pathlib.Path.</p> </li> <li> <code>from_vcf_header</code>             \u2013              <p>Fill a object with VcfHeader.</p> </li> </ul> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise a contigs length.\"\"\"\n    self.lf = polars.LazyFrame(\n        schema={\n            \"contig\": polars.String,\n            \"length\": polars.UInt64,\n            \"offset\": polars.UInt64,\n        }\n    )\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.ContigsLength.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path, /, **scan_csv_args: Unpack[ScanCsv]\n) -&gt; int\n</code></pre> <p>Fill object with file point by pathlib.Path.</p> <p>Argument: path: path of input file</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_path(self, path: pathlib.Path, /, **scan_csv_args: Unpack[ScanCsv]) -&gt; int:\n    \"\"\"Fill object with file point by pathlib.Path.\n\n    Argument:\n    path: path of input file\n\n    Returns: Number of contigs line view\n    \"\"\"\n    csv = Csv()\n    csv.from_path(path, **scan_csv_args)\n    self.lf = csv.lf\n\n    self.__compute_offset()\n\n    return self.lf.collect().shape[0]\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.ContigsLength.from_vcf_header","title":"from_vcf_header","text":"<pre><code>from_vcf_header(header: VcfHeader) -&gt; int\n</code></pre> <p>Fill a object with VcfHeader.</p> Argument <p>header: VcfHeader</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_vcf_header(self, header: VcfHeader) -&gt; int:\n    \"\"\"Fill a object with VcfHeader.\n\n    Argument:\n       header: VcfHeader\n\n    Returns: Number of contigs line view\n    \"\"\"\n    contigs_id = re.compile(r\"ID=(?P&lt;id&gt;[^,]+)\")\n    contigs_len = re.compile(r\"length=(?P&lt;length&gt;[^,&gt;]+)\")\n\n    count = 0\n    contigs2len: dict[str, list] = {\"contig\": [], \"length\": []}\n    for contig_line in header.contigs:\n        if (len_match := contigs_len.search(contig_line)) and (id_match := contigs_id.search(contig_line)):\n            contigs2len[\"contig\"].append(id_match.groupdict()[\"id\"])\n            contigs2len[\"length\"].append(int(len_match.groupdict()[\"length\"]))\n        count += 1\n\n    self.lf = polars.LazyFrame(contigs2len, schema={\"contig\": polars.String, \"length\": polars.UInt64})\n\n    self.__compute_offset()\n\n    return count\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Genotypes","title":"Genotypes","text":"<pre><code>Genotypes(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Genotypes.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> <li> <code>samples_names</code>             \u2013              <p>Get list of sample name.</p> </li> </ul> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Genotypes object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Genotypes.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Genotypes.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"sample\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Genotypes.samples_names","title":"samples_names","text":"<pre><code>samples_names() -&gt; list[str]\n</code></pre> <p>Get list of sample name.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def samples_names(self) -&gt; list[str]:\n    \"\"\"Get list of sample name.\"\"\"\n    return self.lf.select(\"sample\").collect().get_column(\"sample\").to_list()\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Pedigree","title":"Pedigree","text":"<pre><code>Pedigree()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Read a pedigree file in polars.LazyFrame.</p> </li> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> <li> <code>to_path</code>             \u2013              <p>Write pedigree polars.LazyFrame in ped format.</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Variants object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Pedigree.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Pedigree.from_path","title":"from_path","text":"<pre><code>from_path(input_path: Path) -&gt; None\n</code></pre> <p>Read a pedigree file in polars.LazyFrame.</p> <p>Parameters:</p> <ul> <li> <code>input_path</code>               (<code>Path</code>)           \u2013            <p>Path to pedigree file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>A polars.LazyFrame that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def from_path(self, input_path: pathlib.Path) -&gt; None:\n    \"\"\"Read a pedigree file in [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html).\n\n    Args:\n        input_path: Path to pedigree file.\n\n    Returns:\n        A [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')\n    \"\"\"\n    self.lf = polars.scan_csv(\n        input_path,\n        separator=\"\\t\",\n        has_header=False,\n        null_values=[\"None\", \"unknown\"],\n        new_columns=[\n            \"family_id\",\n            \"personal_id\",\n            \"father_id\",\n            \"mother_id\",\n            \"sex\",\n            \"affected\",\n        ],\n        schema_overrides=Pedigree.minimal_schema(),\n    )\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Pedigree.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"family_id\": polars.String,\n        \"personal_id\": polars.String,\n        \"father_id\": polars.String,\n        \"mother_id\": polars.String,\n        \"sex\": polars.String,\n        \"affected\": polars.Boolean,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Pedigree.to_path","title":"to_path","text":"<pre><code>to_path(output_path: Path) -&gt; None\n</code></pre> <p>Write pedigree polars.LazyFrame in ped format.</p> <p>Warning: This function performs polars.LazyFrame.collect before write csv, this can have a significant impact on memory usage</p> <p>Parameters:</p> <ul> <li> <code>lf</code>           \u2013            <p>LazyFrame contains pedigree information.</p> </li> <li> <code>output_path</code>               (<code>Path</code>)           \u2013            <p>Path where write pedigree information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def to_path(self, output_path: pathlib.Path) -&gt; None:\n    \"\"\"Write pedigree [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) in ped format.\n\n    Warning: This function performs [polars.LazyFrame.collect][] before write csv, this can have a significant impact on memory usage\n\n    Args:\n        lf: LazyFrame contains pedigree information.\n        output_path: Path where write pedigree information.\n\n    Returns:\n        None\n    \"\"\"\n    self.lf.collect().write_csv(output_path, include_header=False, separator=\"\\t\")\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Variants","title":"Variants","text":"<pre><code>Variants(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Variants object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Variants.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf","title":"Vcf","text":"<pre><code>Vcf()\n</code></pre> <p>Object to manage lazyframe as Vcf.</p> <p>Methods:</p> <ul> <li> <code>add_genotypes</code>             \u2013              <p>Add genotypes information in vcf.</p> </li> <li> <code>annotations</code>             \u2013              <p>Get annotations of vcf.</p> </li> <li> <code>from_path</code>             \u2013              <p>Populate Vcf object with vcf file.</p> </li> <li> <code>genotypes</code>             \u2013              <p>Get genotype of vcf.</p> </li> <li> <code>schema</code>             \u2013              <p>Get schema of Vcf polars.LazyFrame.</p> </li> <li> <code>set_variants</code>             \u2013              <p>Set variants of vcf.</p> </li> <li> <code>variants</code>             \u2013              <p>Get variants of vcf.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Vcf object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n\n    self.header = VcfHeader()\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf.add_genotypes","title":"add_genotypes","text":"<pre><code>add_genotypes(genotypes_lf: Genotypes) -&gt; None\n</code></pre> <p>Add genotypes information in vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def add_genotypes(self, genotypes_lf: Genotypes) -&gt; None:\n    \"\"\"Add genotypes information in vcf.\"\"\"\n    for sample in genotypes_lf.samples_names():\n        geno2sample = (\n            genotypes_lf.lf.filter(polars.col(\"sample\") == sample)\n            .rename(\n                {col: f\"{sample}_{col}\" for col in genotypes_lf.lf.collect_schema().names()[2:]},\n            )\n            .drop(\"sample\")\n        )\n\n        self.lf = self.lf.join(geno2sample, on=\"id\", how=\"full\", coalesce=True)\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf.annotations","title":"annotations","text":"<pre><code>annotations(\n    select_info: set[str] | None = None,\n) -&gt; Annotations\n</code></pre> <p>Get annotations of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def annotations(self, select_info: set[str] | None = None) -&gt; Annotations:\n    \"\"\"Get annotations of vcf.\"\"\"\n    lf = self.lf.with_columns(self.lf.header.info_parser(select_info))\n\n    return lf.drop(\"chr\", \"pos\", \"ref\", \"alt\", \"format\", \"info\")\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path,\n    chr2len_path: Path | None,\n    behavior: VcfParsingBehavior = NOTHING,\n) -&gt; None\n</code></pre> <p>Populate Vcf object with vcf file.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def from_path(\n    self,\n    path: pathlib.Path,\n    chr2len_path: pathlib.Path | None,\n    behavior: VcfParsingBehavior = VcfParsingBehavior.NOTHING,\n) -&gt; None:\n    \"\"\"Populate Vcf object with vcf file.\"\"\"\n    with open(path) as fh:\n        try:\n            self.header.from_lines(fh)\n        except NotVcfHeaderError as e:\n            raise NotAVCFError(path) from e\n\n    chr2len = ContigsLength()\n    if chr2len_path is not None:\n        if chr2len.from_path(chr2len_path) == 0 and chr2len.from_vcf_header(self.header) == 0:\n            raise NoContigsLengthInformationError\n    elif chr2len.from_vcf_header(self.header) == 0:\n        raise NoContigsLengthInformationError\n\n    self.lf = polars.scan_csv(\n        path,\n        separator=\"\\t\",\n        comment_prefix=\"#\",\n        has_header=False,\n        schema_overrides=Vcf.schema(),\n        new_columns=list(Vcf.schema().keys()),\n    )\n\n    schema = self.lf.collect_schema()\n    self.lf = self.lf.rename(dict(zip(schema.names(), self.header.column_name(schema.len()))))\n    self.lf = self.lf.cast(Vcf.schema())  # type: ignore # noqa: PGH003  polars 1.0 typing stuff\n\n    if behavior == VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.with_columns(self.header.info_parser({\"SVTYPE\", \"SVLEN\"}))\n\n    self.lf = normalization.add_variant_id(self.lf, chr2len.lf)\n\n    if behavior == VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.drop(\"SVTYPE\", \"SVLEN\", strict=False)\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf.genotypes","title":"genotypes","text":"<pre><code>genotypes(format_str: str = 'GT:AD:DP:GQ') -&gt; Genotypes\n</code></pre> <p>Get genotype of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def genotypes(self, format_str: str = \"GT:AD:DP:GQ\") -&gt; Genotypes:\n    \"\"\"Get genotype of vcf.\"\"\"\n    schema = self.lf.collect_schema()\n\n    if \"format\" not in schema.names():\n        raise NoGenotypeError\n\n    lf = self.lf.select([*schema.names()[schema.names().index(\"format\") :]])\n    schema = lf.collect_schema()\n\n    # Clean bad variant\n    lf = lf.filter(polars.col(\"format\").str.starts_with(format_str)).select(*schema.names()[1:])\n\n    # Found index of genotype value\n    col_index = {\n        key: index\n        for (index, key) in enumerate(\n            format_str.split(\":\"),\n        )\n    }\n\n    # Pivot value\n    genotypes = Genotypes()\n    genotypes.lf = lf.unpivot(index=[\"id\"]).with_columns(\n        [\n            polars.col(\"id\"),\n            polars.col(\"variable\").alias(\"sample\"),\n            polars.col(\"value\").str.split(\":\"),\n        ],\n    )\n\n    # Split genotype column in sub value\n    col2expr = self.header.format_parser()\n\n    genotypes.lf = genotypes.lf.with_columns(\n        [\n            polars.col(\"value\").list.get(index).pipe(function=col2expr[col], col_name=col)\n            for col, index in col_index.items()\n        ],\n    )\n\n    # Select intrusting column\n    genotypes.lf = genotypes.lf.select([\"id\", \"sample\", *[col.lower() for col in col_index]])\n\n    if \"gt\".upper() in col2expr:\n        genotypes.lf = genotypes.lf.filter(polars.col(\"gt\") != 0)\n\n    return genotypes\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of Vcf polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>@classmethod\ndef schema(cls) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of Vcf polars.LazyFrame.\"\"\"\n    return {\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"vid\": polars.String,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n        \"qual\": polars.String,\n        \"filter\": polars.String,\n        \"info\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf.set_variants","title":"set_variants","text":"<pre><code>set_variants(variants: Variants) -&gt; None\n</code></pre> <p>Set variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def set_variants(self, variants: Variants) -&gt; None:\n    \"\"\"Set variants of vcf.\"\"\"\n    self.lf = variants.lf\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.Vcf.variants","title":"variants","text":"<pre><code>variants() -&gt; Variants\n</code></pre> <p>Get variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def variants(self) -&gt; Variants:\n    \"\"\"Get variants of vcf.\"\"\"\n    return self.lf.select(Variants.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader","title":"VcfHeader","text":"<pre><code>VcfHeader()\n</code></pre> <p>Object that parse and store vcf information.</p> <p>Methods:</p> <ul> <li> <code>column_name</code>             \u2013              <p>Get an iterator of correct column name.</p> </li> <li> <code>format_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract genotypes information.</p> </li> <li> <code>from_files</code>             \u2013              <p>Populate VcfHeader object with content of only header file.</p> </li> <li> <code>from_lines</code>             \u2013              <p>Extract all header information of vcf lines.</p> </li> <li> <code>info_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract variants information.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>contigs</code>               (<code>Iterator[str]</code>)           \u2013            <p>Get an iterator of line contains chromosomes information.</p> </li> <li> <code>samples_index</code>               (<code>dict[str, int] | None</code>)           \u2013            <p>Read vcf header to generate an association map between sample name and index.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise VcfHeader.\"\"\"\n    self._header = []\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader.contigs","title":"contigs  <code>cached</code> <code>property</code>","text":"<pre><code>contigs: Iterator[str]\n</code></pre> <p>Get an iterator of line contains chromosomes information.</p> <p>Returns: String iterator</p>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader.samples_index","title":"samples_index  <code>cached</code> <code>property</code>","text":"<pre><code>samples_index: dict[str, int] | None\n</code></pre> <p>Read vcf header to generate an association map between sample name and index.</p> <p>Args: header: Header string.</p> <p>Returns: Map that associate a sample name to is sample index.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader.column_name","title":"column_name","text":"<pre><code>column_name(\n    number_of_column: int = MINIMAL_COL_NUMBER,\n) -&gt; Iterator[str]\n</code></pre> <p>Get an iterator of correct column name.</p> <p>Returns: String iterator</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def column_name(self, number_of_column: int = MINIMAL_COL_NUMBER) -&gt; typing.Iterator[str]:\n    \"\"\"Get an iterator of correct column name.\n\n    Returns: String iterator\n    \"\"\"\n    base_col_name = [\"chr\", \"pos\", \"vid\", \"ref\", \"alt\", \"qual\", \"filter\", \"info\"]\n\n    yield from base_col_name\n\n    if number_of_column &gt; MINIMAL_COL_NUMBER and (samples := self.samples_index):\n        yield \"format\"\n        yield from (sample for (sample, _) in samples.items())\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader.format_parser","title":"format_parser","text":"<pre><code>format_parser(\n    select_format: set[str] | None = None,\n) -&gt; dict[str, Callable[[Expr, str], Expr]]\n</code></pre> <p>Generate a list of polars.Expr to extract genotypes information.</p> <p>Warning: Float values can't be converted for the moment they are stored as String to keep information</p> <p>Args: header: Line of vcf header. input_path: Path to vcf file. select_format: List of target format field.</p> <p>Returns: A dict to link format id to pipeable function with Polars.Expr</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def format_parser(\n    self,\n    select_format: set[str] | None = None,\n) -&gt; dict[str, typing.Callable[[polars.Expr, str], polars.Expr]]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract genotypes information.\n\n    **Warning**: Float values can't be converted for the moment they are stored as String to keep information\n\n    Args:\n    header: Line of vcf header.\n    input_path: Path to vcf file.\n    select_format: List of target format field.\n\n    Returns:\n    A dict to link format id to pipeable function with Polars.Expr\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    format_re = re.compile(\n        \"ID=(?P&lt;id&gt;[A-Za-z_][0-9A-Za-z_.]*),Number=(?P&lt;number&gt;[ARG0-9\\\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: dict[str, typing.Callable[[polars.Expr, str], polars.Expr]] = {}\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##FORMAT\"):\n            continue\n\n        if (search := format_re.search(line)) and (not select_format or search[\"id\"] in select_format):\n            name = search[\"id\"]\n            number = search[\"number\"]\n            format_type = search[\"type\"]\n\n            if name == \"GT\":\n                expressions[\"GT\"] = VcfHeader.__format_gt\n                continue\n\n            if number == \"1\":\n                if format_type == \"Integer\":\n                    expressions[name] = VcfHeader.__format_one_int\n                elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                    expressions[name] = VcfHeader.__format_one_str\n                elif format_type in {\"String\", \"Character\"}:\n                    expressions[name] = VcfHeader.__format_one_str\n                else:\n                    pass  # Not reachable\n\n            elif format_type == \"Integer\":\n                expressions[name] = VcfHeader.__format_list_int\n            elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                expressions[name] = VcfHeader.__format_list_str\n            elif format_type in {\"String\", \"Character\"}:\n                expressions[name] = VcfHeader.__format_list_str\n            else:\n                pass  # Not reachable\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader.from_files","title":"from_files","text":"<pre><code>from_files(path: Path) -&gt; None\n</code></pre> <p>Populate VcfHeader object with content of only header file.</p> <p>Args: path: Path of file</p> <p>Returns: None</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_files(self, path: pathlib.Path) -&gt; None:\n    \"\"\"Populate VcfHeader object with content of only header file.\n\n    Args:\n    path: Path of file\n\n    Returns:\n    None\n    \"\"\"\n    with open(path) as fh:\n        for full_line in fh:\n            line = full_line.strip()\n            self._header.append(line)\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader.from_lines","title":"from_lines","text":"<pre><code>from_lines(lines: Iterator[str]) -&gt; None\n</code></pre> <p>Extract all header information of vcf lines.</p> <p>Line between start of file and first line start with '#CHROM' or not start with '#'</p> <p>Args: lines: Iterator of line</p> <p>Returns: None</p> <p>Raises: NotAVcfHeader: If a line not starts with '#' NotAVcfHeader: If no line start by '#CHROM'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_lines(self, lines: typing.Iterator[str]) -&gt; None:\n    \"\"\"Extract all header information of vcf lines.\n\n    Line between start of file and first line start with '#CHROM' or not start with '#'\n\n    Args:\n    lines: Iterator of line\n\n    Returns: None\n\n    Raises:\n    NotAVcfHeader: If a line not starts with '#'\n    NotAVcfHeader: If no line start by '#CHROM'\n    \"\"\"\n    for full_line in lines:\n        line = full_line.strip()\n\n        if not line.startswith(\"#\"):\n            raise NotVcfHeaderError\n\n        if line.startswith(\"#CHROM\"):\n            self._header.append(line)\n            return\n\n        self._header.append(line)\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfHeader.info_parser","title":"info_parser","text":"<pre><code>info_parser(\n    select_info: set[str] | None = None,\n) -&gt; list[Expr]\n</code></pre> <p>Generate a list of polars.Expr to extract variants information.</p> <p>Args: header: Line of vcf header input_path: Path to vcf file. select_info: List of target info field</p> <p>Returns: List of polars.Expr to parse info columns.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def info_parser(self, select_info: set[str] | None = None) -&gt; list[polars.Expr]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract variants information.\n\n    Args:\n    header: Line of vcf header\n    input_path: Path to vcf file.\n    select_info: List of target info field\n\n    Returns:\n    List of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to parse info columns.\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    info_re = re.compile(\n        r\"ID=(?P&lt;id&gt;([A-Za-z_][0-9A-Za-z_.]*|1000G)),Number=(?P&lt;number&gt;[ARG0-9\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: list[polars.Expr] = []\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##INFO\"):\n            continue\n\n        if (search := info_re.search(line)) and (not select_info or search[\"id\"] in select_info):\n            regex = rf\"{search['id']}=([^;]+);?\"\n\n            local_expr = polars.col(\"info\").str.extract(regex, 1)\n\n            if search[\"number\"] == \"1\":\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.Int64)\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.Float64)\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            else:\n                local_expr = local_expr.str.split(\",\")\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.List(polars.Int64))\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.List(polars.Float64))\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            expressions.append(local_expr.alias(search[\"id\"]))\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfParsingBehavior","title":"VcfParsingBehavior","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration use to control behavior of IntoLazyFrame.</p> <p>Attributes:</p> <ul> <li> <code>MANAGE_SV</code>           \u2013            <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p> </li> <li> <code>NOTHING</code>           \u2013            <p>into_lazyframe not have any specific behavior</p> </li> </ul>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfParsingBehavior.MANAGE_SV","title":"MANAGE_SV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MANAGE_SV = 1\n</code></pre> <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p>"},{"location":"reference/variantplaner/objects/#variantplaner.objects.VcfParsingBehavior.NOTHING","title":"NOTHING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOTHING = 0\n</code></pre> <p>into_lazyframe not have any specific behavior</p>"},{"location":"reference/variantplaner/objects/annotations/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> annotations","text":""},{"location":"reference/variantplaner/objects/annotations/#variantplaner.objects.annotations","title":"annotations","text":"<p>Declare Genotypes object.</p> <p>Classes:</p> <ul> <li> <code>Annotations</code>           \u2013            <p>Object to manage lazyframe as Annotations.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/annotations/#variantplaner.objects.annotations.Annotations","title":"Annotations","text":"<pre><code>Annotations()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Annotations.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Annotations object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Annotations.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/objects/annotations/#variantplaner.objects.annotations.Annotations.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/contigs_length/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> contigs_length","text":""},{"location":"reference/variantplaner/objects/contigs_length/#variantplaner.objects.contigs_length","title":"contigs_length","text":"<p>Declare Vcf object.</p> <p>Classes:</p> <ul> <li> <code>ContigsLength</code>           \u2013            <p>Store contigs -&gt; length information.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/contigs_length/#variantplaner.objects.contigs_length.ContigsLength","title":"ContigsLength","text":"<pre><code>ContigsLength()\n</code></pre> <p>Store contigs -&gt; length information.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Fill object with file point by pathlib.Path.</p> </li> <li> <code>from_vcf_header</code>             \u2013              <p>Fill a object with VcfHeader.</p> </li> </ul> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise a contigs length.\"\"\"\n    self.lf = polars.LazyFrame(\n        schema={\n            \"contig\": polars.String,\n            \"length\": polars.UInt64,\n            \"offset\": polars.UInt64,\n        }\n    )\n</code></pre>"},{"location":"reference/variantplaner/objects/contigs_length/#variantplaner.objects.contigs_length.ContigsLength.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path, /, **scan_csv_args: Unpack[ScanCsv]\n) -&gt; int\n</code></pre> <p>Fill object with file point by pathlib.Path.</p> <p>Argument: path: path of input file</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_path(self, path: pathlib.Path, /, **scan_csv_args: Unpack[ScanCsv]) -&gt; int:\n    \"\"\"Fill object with file point by pathlib.Path.\n\n    Argument:\n    path: path of input file\n\n    Returns: Number of contigs line view\n    \"\"\"\n    csv = Csv()\n    csv.from_path(path, **scan_csv_args)\n    self.lf = csv.lf\n\n    self.__compute_offset()\n\n    return self.lf.collect().shape[0]\n</code></pre>"},{"location":"reference/variantplaner/objects/contigs_length/#variantplaner.objects.contigs_length.ContigsLength.from_vcf_header","title":"from_vcf_header","text":"<pre><code>from_vcf_header(header: VcfHeader) -&gt; int\n</code></pre> <p>Fill a object with VcfHeader.</p> Argument <p>header: VcfHeader</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_vcf_header(self, header: VcfHeader) -&gt; int:\n    \"\"\"Fill a object with VcfHeader.\n\n    Argument:\n       header: VcfHeader\n\n    Returns: Number of contigs line view\n    \"\"\"\n    contigs_id = re.compile(r\"ID=(?P&lt;id&gt;[^,]+)\")\n    contigs_len = re.compile(r\"length=(?P&lt;length&gt;[^,&gt;]+)\")\n\n    count = 0\n    contigs2len: dict[str, list] = {\"contig\": [], \"length\": []}\n    for contig_line in header.contigs:\n        if (len_match := contigs_len.search(contig_line)) and (id_match := contigs_id.search(contig_line)):\n            contigs2len[\"contig\"].append(id_match.groupdict()[\"id\"])\n            contigs2len[\"length\"].append(int(len_match.groupdict()[\"length\"]))\n        count += 1\n\n    self.lf = polars.LazyFrame(contigs2len, schema={\"contig\": polars.String, \"length\": polars.UInt64})\n\n    self.__compute_offset()\n\n    return count\n</code></pre>"},{"location":"reference/variantplaner/objects/csv/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> csv","text":""},{"location":"reference/variantplaner/objects/csv/#variantplaner.objects.csv","title":"csv","text":"<p>Declare CSV object.</p> <p>Classes:</p> <ul> <li> <code>ColRename</code>           \u2013            <p>A struct to store rename parameter.</p> </li> <li> <code>Csv</code>           \u2013            <p>Object to manage lazyframe as Csv.</p> </li> <li> <code>ScanCsv</code>           \u2013            <p>A struct to check type of parameter give to polars.scan_csv.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/csv/#variantplaner.objects.csv.ColRename","title":"ColRename  <code>dataclass</code>","text":"<pre><code>ColRename(\n    chr: str = \"chr\",\n    ref: str = \"ref\",\n    alt: str = \"alt\",\n    other: dict[str, str] = dict(),\n)\n</code></pre> <p>A struct to store rename parameter.</p>"},{"location":"reference/variantplaner/objects/csv/#variantplaner.objects.csv.Csv","title":"Csv","text":"<pre><code>Csv()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Csv.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Populate Csv obejct with csv file content.</p> </li> <li> <code>variants_from_path</code>             \u2013              <p>Populate Csv object with csv file.</p> </li> </ul> Source code in <code>src/variantplaner/objects/csv.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Csv object.\"\"\"\n    self.lf = polars.LazyFrame()\n</code></pre>"},{"location":"reference/variantplaner/objects/csv/#variantplaner.objects.csv.Csv.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path, /, **scan_csv_args: Unpack[ScanCsv]\n) -&gt; None\n</code></pre> <p>Populate Csv obejct with csv file content.</p> Source code in <code>src/variantplaner/objects/csv.py</code> <pre><code>def from_path(self, path: pathlib.Path, /, **scan_csv_args: Unpack[ScanCsv]) -&gt; None:\n    \"\"\"Populate Csv obejct with csv file content.\"\"\"\n    self.lf = polars.scan_csv(path, **scan_csv_args)\n</code></pre>"},{"location":"reference/variantplaner/objects/csv/#variantplaner.objects.csv.Csv.variants_from_path","title":"variants_from_path","text":"<pre><code>variants_from_path(\n    path: Path,\n    col_rename: ColRename,\n    /,\n    **scan_csv_args: Unpack[ScanCsv],\n) -&gt; None\n</code></pre> <p>Populate Csv object with csv file.</p> Source code in <code>src/variantplaner/objects/csv.py</code> <pre><code>def variants_from_path(\n    self, path: pathlib.Path, col_rename: ColRename, /, **scan_csv_args: Unpack[ScanCsv]\n) -&gt; None:\n    \"\"\"Populate Csv object with csv file.\"\"\"\n    self.from_path(path, **scan_csv_args)\n\n    self.lf = self.lf.rename(dataclasses.asdict(col_rename))\n\n    if any(elt not in super().columns for elt in [\"chr\", \"pos\", \"ref\", \"alt\"]):\n        raise NotAVariantCsvError(path)\n\n    self.lf = self.lf.cast({\"pos\": polars.UInt64})\n</code></pre>"},{"location":"reference/variantplaner/objects/csv/#variantplaner.objects.csv.ScanCsv","title":"ScanCsv","text":"<p>               Bases: <code>TypedDict</code></p> <p>A struct to check type of parameter give to polars.scan_csv.</p>"},{"location":"reference/variantplaner/objects/genotypes/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> genotypes","text":""},{"location":"reference/variantplaner/objects/genotypes/#variantplaner.objects.genotypes","title":"genotypes","text":"<p>Declare Genotypes object.</p> <p>Classes:</p> <ul> <li> <code>Genotypes</code>           \u2013            <p>Object to manage lazyframe as Genotypes.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/genotypes/#variantplaner.objects.genotypes.Genotypes","title":"Genotypes","text":"<pre><code>Genotypes(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Genotypes.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> <li> <code>samples_names</code>             \u2013              <p>Get list of sample name.</p> </li> </ul> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Genotypes object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Genotypes.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/variantplaner/objects/genotypes/#variantplaner.objects.genotypes.Genotypes.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"sample\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/genotypes/#variantplaner.objects.genotypes.Genotypes.samples_names","title":"samples_names","text":"<pre><code>samples_names() -&gt; list[str]\n</code></pre> <p>Get list of sample name.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def samples_names(self) -&gt; list[str]:\n    \"\"\"Get list of sample name.\"\"\"\n    return self.lf.select(\"sample\").collect().get_column(\"sample\").to_list()\n</code></pre>"},{"location":"reference/variantplaner/objects/pedigree/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> pedigree","text":""},{"location":"reference/variantplaner/objects/pedigree/#variantplaner.objects.pedigree","title":"pedigree","text":"<p>Declare Pedigree object.</p> <p>Classes:</p> <ul> <li> <code>Pedigree</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/pedigree/#variantplaner.objects.pedigree.Pedigree","title":"Pedigree","text":"<pre><code>Pedigree()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Read a pedigree file in polars.LazyFrame.</p> </li> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> <li> <code>to_path</code>             \u2013              <p>Write pedigree polars.LazyFrame in ped format.</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Variants object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Pedigree.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/objects/pedigree/#variantplaner.objects.pedigree.Pedigree.from_path","title":"from_path","text":"<pre><code>from_path(input_path: Path) -&gt; None\n</code></pre> <p>Read a pedigree file in polars.LazyFrame.</p> <p>Parameters:</p> <ul> <li> <code>input_path</code>               (<code>Path</code>)           \u2013            <p>Path to pedigree file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>A polars.LazyFrame that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def from_path(self, input_path: pathlib.Path) -&gt; None:\n    \"\"\"Read a pedigree file in [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html).\n\n    Args:\n        input_path: Path to pedigree file.\n\n    Returns:\n        A [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')\n    \"\"\"\n    self.lf = polars.scan_csv(\n        input_path,\n        separator=\"\\t\",\n        has_header=False,\n        null_values=[\"None\", \"unknown\"],\n        new_columns=[\n            \"family_id\",\n            \"personal_id\",\n            \"father_id\",\n            \"mother_id\",\n            \"sex\",\n            \"affected\",\n        ],\n        schema_overrides=Pedigree.minimal_schema(),\n    )\n</code></pre>"},{"location":"reference/variantplaner/objects/pedigree/#variantplaner.objects.pedigree.Pedigree.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"family_id\": polars.String,\n        \"personal_id\": polars.String,\n        \"father_id\": polars.String,\n        \"mother_id\": polars.String,\n        \"sex\": polars.String,\n        \"affected\": polars.Boolean,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/pedigree/#variantplaner.objects.pedigree.Pedigree.to_path","title":"to_path","text":"<pre><code>to_path(output_path: Path) -&gt; None\n</code></pre> <p>Write pedigree polars.LazyFrame in ped format.</p> <p>Warning: This function performs polars.LazyFrame.collect before write csv, this can have a significant impact on memory usage</p> <p>Parameters:</p> <ul> <li> <code>lf</code>           \u2013            <p>LazyFrame contains pedigree information.</p> </li> <li> <code>output_path</code>               (<code>Path</code>)           \u2013            <p>Path where write pedigree information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def to_path(self, output_path: pathlib.Path) -&gt; None:\n    \"\"\"Write pedigree [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) in ped format.\n\n    Warning: This function performs [polars.LazyFrame.collect][] before write csv, this can have a significant impact on memory usage\n\n    Args:\n        lf: LazyFrame contains pedigree information.\n        output_path: Path where write pedigree information.\n\n    Returns:\n        None\n    \"\"\"\n    self.lf.collect().write_csv(output_path, include_header=False, separator=\"\\t\")\n</code></pre>"},{"location":"reference/variantplaner/objects/variants/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> variants","text":""},{"location":"reference/variantplaner/objects/variants/#variantplaner.objects.variants","title":"variants","text":"<p>Declare Variants object.</p> <p>Classes:</p> <ul> <li> <code>Variants</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/variants/#variantplaner.objects.variants.Variants","title":"Variants","text":"<pre><code>Variants(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Variants object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/variantplaner/objects/variants/#variantplaner.objects.variants.Variants.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> vcf","text":""},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf","title":"vcf","text":"<p>Declare Vcf object.</p> <p>Modules:</p> <ul> <li> <code>normalization</code>           \u2013            <p>Function use to normalize data.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Vcf</code>           \u2013            <p>Object to manage lazyframe as Vcf.</p> </li> <li> <code>VcfParsingBehavior</code>           \u2013            <p>Enumeration use to control behavior of IntoLazyFrame.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf","title":"Vcf","text":"<pre><code>Vcf()\n</code></pre> <p>Object to manage lazyframe as Vcf.</p> <p>Methods:</p> <ul> <li> <code>add_genotypes</code>             \u2013              <p>Add genotypes information in vcf.</p> </li> <li> <code>annotations</code>             \u2013              <p>Get annotations of vcf.</p> </li> <li> <code>from_path</code>             \u2013              <p>Populate Vcf object with vcf file.</p> </li> <li> <code>genotypes</code>             \u2013              <p>Get genotype of vcf.</p> </li> <li> <code>schema</code>             \u2013              <p>Get schema of Vcf polars.LazyFrame.</p> </li> <li> <code>set_variants</code>             \u2013              <p>Set variants of vcf.</p> </li> <li> <code>variants</code>             \u2013              <p>Get variants of vcf.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Vcf object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n\n    self.header = VcfHeader()\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf.add_genotypes","title":"add_genotypes","text":"<pre><code>add_genotypes(genotypes_lf: Genotypes) -&gt; None\n</code></pre> <p>Add genotypes information in vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def add_genotypes(self, genotypes_lf: Genotypes) -&gt; None:\n    \"\"\"Add genotypes information in vcf.\"\"\"\n    for sample in genotypes_lf.samples_names():\n        geno2sample = (\n            genotypes_lf.lf.filter(polars.col(\"sample\") == sample)\n            .rename(\n                {col: f\"{sample}_{col}\" for col in genotypes_lf.lf.collect_schema().names()[2:]},\n            )\n            .drop(\"sample\")\n        )\n\n        self.lf = self.lf.join(geno2sample, on=\"id\", how=\"full\", coalesce=True)\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf.annotations","title":"annotations","text":"<pre><code>annotations(\n    select_info: set[str] | None = None,\n) -&gt; Annotations\n</code></pre> <p>Get annotations of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def annotations(self, select_info: set[str] | None = None) -&gt; Annotations:\n    \"\"\"Get annotations of vcf.\"\"\"\n    lf = self.lf.with_columns(self.lf.header.info_parser(select_info))\n\n    return lf.drop(\"chr\", \"pos\", \"ref\", \"alt\", \"format\", \"info\")\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path,\n    chr2len_path: Path | None,\n    behavior: VcfParsingBehavior = NOTHING,\n) -&gt; None\n</code></pre> <p>Populate Vcf object with vcf file.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def from_path(\n    self,\n    path: pathlib.Path,\n    chr2len_path: pathlib.Path | None,\n    behavior: VcfParsingBehavior = VcfParsingBehavior.NOTHING,\n) -&gt; None:\n    \"\"\"Populate Vcf object with vcf file.\"\"\"\n    with open(path) as fh:\n        try:\n            self.header.from_lines(fh)\n        except NotVcfHeaderError as e:\n            raise NotAVCFError(path) from e\n\n    chr2len = ContigsLength()\n    if chr2len_path is not None:\n        if chr2len.from_path(chr2len_path) == 0 and chr2len.from_vcf_header(self.header) == 0:\n            raise NoContigsLengthInformationError\n    elif chr2len.from_vcf_header(self.header) == 0:\n        raise NoContigsLengthInformationError\n\n    self.lf = polars.scan_csv(\n        path,\n        separator=\"\\t\",\n        comment_prefix=\"#\",\n        has_header=False,\n        schema_overrides=Vcf.schema(),\n        new_columns=list(Vcf.schema().keys()),\n    )\n\n    schema = self.lf.collect_schema()\n    self.lf = self.lf.rename(dict(zip(schema.names(), self.header.column_name(schema.len()))))\n    self.lf = self.lf.cast(Vcf.schema())  # type: ignore # noqa: PGH003  polars 1.0 typing stuff\n\n    if behavior == VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.with_columns(self.header.info_parser({\"SVTYPE\", \"SVLEN\"}))\n\n    self.lf = normalization.add_variant_id(self.lf, chr2len.lf)\n\n    if behavior == VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.drop(\"SVTYPE\", \"SVLEN\", strict=False)\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf.genotypes","title":"genotypes","text":"<pre><code>genotypes(format_str: str = 'GT:AD:DP:GQ') -&gt; Genotypes\n</code></pre> <p>Get genotype of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def genotypes(self, format_str: str = \"GT:AD:DP:GQ\") -&gt; Genotypes:\n    \"\"\"Get genotype of vcf.\"\"\"\n    schema = self.lf.collect_schema()\n\n    if \"format\" not in schema.names():\n        raise NoGenotypeError\n\n    lf = self.lf.select([*schema.names()[schema.names().index(\"format\") :]])\n    schema = lf.collect_schema()\n\n    # Clean bad variant\n    lf = lf.filter(polars.col(\"format\").str.starts_with(format_str)).select(*schema.names()[1:])\n\n    # Found index of genotype value\n    col_index = {\n        key: index\n        for (index, key) in enumerate(\n            format_str.split(\":\"),\n        )\n    }\n\n    # Pivot value\n    genotypes = Genotypes()\n    genotypes.lf = lf.unpivot(index=[\"id\"]).with_columns(\n        [\n            polars.col(\"id\"),\n            polars.col(\"variable\").alias(\"sample\"),\n            polars.col(\"value\").str.split(\":\"),\n        ],\n    )\n\n    # Split genotype column in sub value\n    col2expr = self.header.format_parser()\n\n    genotypes.lf = genotypes.lf.with_columns(\n        [\n            polars.col(\"value\").list.get(index).pipe(function=col2expr[col], col_name=col)\n            for col, index in col_index.items()\n        ],\n    )\n\n    # Select intrusting column\n    genotypes.lf = genotypes.lf.select([\"id\", \"sample\", *[col.lower() for col in col_index]])\n\n    if \"gt\".upper() in col2expr:\n        genotypes.lf = genotypes.lf.filter(polars.col(\"gt\") != 0)\n\n    return genotypes\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of Vcf polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>@classmethod\ndef schema(cls) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of Vcf polars.LazyFrame.\"\"\"\n    return {\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"vid\": polars.String,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n        \"qual\": polars.String,\n        \"filter\": polars.String,\n        \"info\": polars.String,\n    }\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf.set_variants","title":"set_variants","text":"<pre><code>set_variants(variants: Variants) -&gt; None\n</code></pre> <p>Set variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def set_variants(self, variants: Variants) -&gt; None:\n    \"\"\"Set variants of vcf.\"\"\"\n    self.lf = variants.lf\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.Vcf.variants","title":"variants","text":"<pre><code>variants() -&gt; Variants\n</code></pre> <p>Get variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def variants(self) -&gt; Variants:\n    \"\"\"Get variants of vcf.\"\"\"\n    return self.lf.select(Variants.minimal_schema())\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.VcfParsingBehavior","title":"VcfParsingBehavior","text":"<p>               Bases: <code>Enum</code></p> <p>Enumeration use to control behavior of IntoLazyFrame.</p> <p>Attributes:</p> <ul> <li> <code>MANAGE_SV</code>           \u2013            <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p> </li> <li> <code>NOTHING</code>           \u2013            <p>into_lazyframe not have any specific behavior</p> </li> </ul>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.VcfParsingBehavior.MANAGE_SV","title":"MANAGE_SV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MANAGE_SV = 1\n</code></pre> <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p>"},{"location":"reference/variantplaner/objects/vcf/#variantplaner.objects.vcf.VcfParsingBehavior.NOTHING","title":"NOTHING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOTHING = 0\n</code></pre> <p>into_lazyframe not have any specific behavior</p>"},{"location":"reference/variantplaner/objects/vcf_header/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> vcf_header","text":""},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header","title":"vcf_header","text":"<p>Declare Vcf object.</p> <p>Classes:</p> <ul> <li> <code>VcfHeader</code>           \u2013            <p>Object that parse and store vcf information.</p> </li> </ul>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader","title":"VcfHeader","text":"<pre><code>VcfHeader()\n</code></pre> <p>Object that parse and store vcf information.</p> <p>Methods:</p> <ul> <li> <code>column_name</code>             \u2013              <p>Get an iterator of correct column name.</p> </li> <li> <code>format_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract genotypes information.</p> </li> <li> <code>from_files</code>             \u2013              <p>Populate VcfHeader object with content of only header file.</p> </li> <li> <code>from_lines</code>             \u2013              <p>Extract all header information of vcf lines.</p> </li> <li> <code>info_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract variants information.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>contigs</code>               (<code>Iterator[str]</code>)           \u2013            <p>Get an iterator of line contains chromosomes information.</p> </li> <li> <code>samples_index</code>               (<code>dict[str, int] | None</code>)           \u2013            <p>Read vcf header to generate an association map between sample name and index.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise VcfHeader.\"\"\"\n    self._header = []\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader.contigs","title":"contigs  <code>cached</code> <code>property</code>","text":"<pre><code>contigs: Iterator[str]\n</code></pre> <p>Get an iterator of line contains chromosomes information.</p> <p>Returns: String iterator</p>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader.samples_index","title":"samples_index  <code>cached</code> <code>property</code>","text":"<pre><code>samples_index: dict[str, int] | None\n</code></pre> <p>Read vcf header to generate an association map between sample name and index.</p> <p>Args: header: Header string.</p> <p>Returns: Map that associate a sample name to is sample index.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader.column_name","title":"column_name","text":"<pre><code>column_name(\n    number_of_column: int = MINIMAL_COL_NUMBER,\n) -&gt; Iterator[str]\n</code></pre> <p>Get an iterator of correct column name.</p> <p>Returns: String iterator</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def column_name(self, number_of_column: int = MINIMAL_COL_NUMBER) -&gt; typing.Iterator[str]:\n    \"\"\"Get an iterator of correct column name.\n\n    Returns: String iterator\n    \"\"\"\n    base_col_name = [\"chr\", \"pos\", \"vid\", \"ref\", \"alt\", \"qual\", \"filter\", \"info\"]\n\n    yield from base_col_name\n\n    if number_of_column &gt; MINIMAL_COL_NUMBER and (samples := self.samples_index):\n        yield \"format\"\n        yield from (sample for (sample, _) in samples.items())\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader.format_parser","title":"format_parser","text":"<pre><code>format_parser(\n    select_format: set[str] | None = None,\n) -&gt; dict[str, Callable[[Expr, str], Expr]]\n</code></pre> <p>Generate a list of polars.Expr to extract genotypes information.</p> <p>Warning: Float values can't be converted for the moment they are stored as String to keep information</p> <p>Args: header: Line of vcf header. input_path: Path to vcf file. select_format: List of target format field.</p> <p>Returns: A dict to link format id to pipeable function with Polars.Expr</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def format_parser(\n    self,\n    select_format: set[str] | None = None,\n) -&gt; dict[str, typing.Callable[[polars.Expr, str], polars.Expr]]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract genotypes information.\n\n    **Warning**: Float values can't be converted for the moment they are stored as String to keep information\n\n    Args:\n    header: Line of vcf header.\n    input_path: Path to vcf file.\n    select_format: List of target format field.\n\n    Returns:\n    A dict to link format id to pipeable function with Polars.Expr\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    format_re = re.compile(\n        \"ID=(?P&lt;id&gt;[A-Za-z_][0-9A-Za-z_.]*),Number=(?P&lt;number&gt;[ARG0-9\\\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: dict[str, typing.Callable[[polars.Expr, str], polars.Expr]] = {}\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##FORMAT\"):\n            continue\n\n        if (search := format_re.search(line)) and (not select_format or search[\"id\"] in select_format):\n            name = search[\"id\"]\n            number = search[\"number\"]\n            format_type = search[\"type\"]\n\n            if name == \"GT\":\n                expressions[\"GT\"] = VcfHeader.__format_gt\n                continue\n\n            if number == \"1\":\n                if format_type == \"Integer\":\n                    expressions[name] = VcfHeader.__format_one_int\n                elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                    expressions[name] = VcfHeader.__format_one_str\n                elif format_type in {\"String\", \"Character\"}:\n                    expressions[name] = VcfHeader.__format_one_str\n                else:\n                    pass  # Not reachable\n\n            elif format_type == \"Integer\":\n                expressions[name] = VcfHeader.__format_list_int\n            elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                expressions[name] = VcfHeader.__format_list_str\n            elif format_type in {\"String\", \"Character\"}:\n                expressions[name] = VcfHeader.__format_list_str\n            else:\n                pass  # Not reachable\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader.from_files","title":"from_files","text":"<pre><code>from_files(path: Path) -&gt; None\n</code></pre> <p>Populate VcfHeader object with content of only header file.</p> <p>Args: path: Path of file</p> <p>Returns: None</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_files(self, path: pathlib.Path) -&gt; None:\n    \"\"\"Populate VcfHeader object with content of only header file.\n\n    Args:\n    path: Path of file\n\n    Returns:\n    None\n    \"\"\"\n    with open(path) as fh:\n        for full_line in fh:\n            line = full_line.strip()\n            self._header.append(line)\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader.from_lines","title":"from_lines","text":"<pre><code>from_lines(lines: Iterator[str]) -&gt; None\n</code></pre> <p>Extract all header information of vcf lines.</p> <p>Line between start of file and first line start with '#CHROM' or not start with '#'</p> <p>Args: lines: Iterator of line</p> <p>Returns: None</p> <p>Raises: NotAVcfHeader: If a line not starts with '#' NotAVcfHeader: If no line start by '#CHROM'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_lines(self, lines: typing.Iterator[str]) -&gt; None:\n    \"\"\"Extract all header information of vcf lines.\n\n    Line between start of file and first line start with '#CHROM' or not start with '#'\n\n    Args:\n    lines: Iterator of line\n\n    Returns: None\n\n    Raises:\n    NotAVcfHeader: If a line not starts with '#'\n    NotAVcfHeader: If no line start by '#CHROM'\n    \"\"\"\n    for full_line in lines:\n        line = full_line.strip()\n\n        if not line.startswith(\"#\"):\n            raise NotVcfHeaderError\n\n        if line.startswith(\"#CHROM\"):\n            self._header.append(line)\n            return\n\n        self._header.append(line)\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/objects/vcf_header/#variantplaner.objects.vcf_header.VcfHeader.info_parser","title":"info_parser","text":"<pre><code>info_parser(\n    select_info: set[str] | None = None,\n) -&gt; list[Expr]\n</code></pre> <p>Generate a list of polars.Expr to extract variants information.</p> <p>Args: header: Line of vcf header input_path: Path to vcf file. select_info: List of target info field</p> <p>Returns: List of polars.Expr to parse info columns.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def info_parser(self, select_info: set[str] | None = None) -&gt; list[polars.Expr]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract variants information.\n\n    Args:\n    header: Line of vcf header\n    input_path: Path to vcf file.\n    select_info: List of target info field\n\n    Returns:\n    List of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to parse info columns.\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    info_re = re.compile(\n        r\"ID=(?P&lt;id&gt;([A-Za-z_][0-9A-Za-z_.]*|1000G)),Number=(?P&lt;number&gt;[ARG0-9\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: list[polars.Expr] = []\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##INFO\"):\n            continue\n\n        if (search := info_re.search(line)) and (not select_info or search[\"id\"] in select_info):\n            regex = rf\"{search['id']}=([^;]+);?\"\n\n            local_expr = polars.col(\"info\").str.extract(regex, 1)\n\n            if search[\"number\"] == \"1\":\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.Int64)\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.Float64)\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            else:\n                local_expr = local_expr.str.split(\",\")\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.List(polars.Int64))\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.List(polars.Float64))\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            expressions.append(local_expr.alias(search[\"id\"]))\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/variantplaner/struct/","title":"Index","text":""},{"location":"reference/variantplaner/struct/#variantplaner.struct","title":"struct","text":"<p>Generated data structures for easy integration.</p> <p>Modules:</p> <ul> <li> <code>genotypes</code>           \u2013            <p>Function relate to genotype structuration.</p> </li> <li> <code>variants</code>           \u2013            <p>Function relate to vcf structuration.</p> </li> </ul>"},{"location":"reference/variantplaner/struct/genotypes/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> genotypes","text":""},{"location":"reference/variantplaner/struct/genotypes/#variantplaner.struct.genotypes","title":"genotypes","text":"<p>Function relate to genotype structuration.</p> <p>Modules:</p> <ul> <li> <code>normalization</code>           \u2013            <p>Function use to normalize data.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>hive</code>             \u2013              <p>Read all genotypes parquet file and use information to generate a hive like struct, based on 63rd and 55th bits included of variant id with genotype information.</p> </li> </ul>"},{"location":"reference/variantplaner/struct/genotypes/#variantplaner.struct.genotypes.hive","title":"hive","text":"<pre><code>hive(\n    paths: list[Path],\n    output_prefix: Path,\n    threads: int,\n    file_per_thread: int,\n    *,\n    append: bool,\n    number_of_bits: int = 8\n) -&gt; None\n</code></pre> <p>Read all genotypes parquet file and use information to generate a hive like struct, based on 63rd and 55th bits included of variant id with genotype information.</p> <p>Real number of threads use are equal to \\(min(threads, len(paths))\\).</p> <p>Output format look like: <code>{output_prefix}/id_part=[0..2.pow(number_of_bits)]/0.parquet</code>.</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>list[Path]</code>)           \u2013            <p>list of file you want reorganize</p> </li> <li> <code>output_prefix</code>               (<code>Path</code>)           \u2013            <p>prefix of hive</p> </li> <li> <code>threads</code>               (<code>int</code>)           \u2013            <p>number of multiprocessing threads run</p> </li> <li> <code>file_per_thread</code>               (<code>int</code>)           \u2013            <p>number of file manage per multiprocessing threads</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/variantplaner/struct/genotypes.py</code> <pre><code>def hive(\n    paths: list[pathlib.Path],\n    output_prefix: pathlib.Path,\n    threads: int,\n    file_per_thread: int,\n    *,\n    append: bool,\n    number_of_bits: int = 8,\n) -&gt; None:\n    r\"\"\"Read all genotypes parquet file and use information to generate a hive like struct, based on 63rd and 55th bits included of variant id with genotype information.\n\n    Real number of threads use are equal to $min(threads, len(paths))$.\n\n    Output format look like: `{output_prefix}/id_part=[0..2.pow(number_of_bits)]/0.parquet`.\n\n    Args:\n        paths: list of file you want reorganize\n        output_prefix: prefix of hive\n        threads: number of multiprocessing threads run\n        file_per_thread: number of file manage per multiprocessing threads\n\n    Returns:\n        None\n    \"\"\"\n    logger.info(f\"{paths=} {output_prefix=}, {threads=}, {file_per_thread=}, {append=} {number_of_bits=}\")\n\n    if len(paths) == 0:\n        return\n\n    for i in range(pow(2, number_of_bits)):\n        (output_prefix / f\"id_part={i}\").mkdir(parents=True, exist_ok=True)\n\n    path_groups: typing.Iterable[typing.Iterable[pathlib.Path]] = list(\n        [[path] for path in paths]\n        if file_per_thread &lt; 2  # noqa: PLR2004 if number of file is lower than 2 file grouping isn't required\n        else itertools.zip_longest(\n            *[iter(paths)] * file_per_thread,\n        ),\n    )\n\n    basenames = [\"_\".join(p.stem for p in g_paths if p is not None) for g_paths in path_groups]\n\n    lf_groups = [[polars.scan_parquet(p) for p in g_paths if p is not None] for g_paths in path_groups]\n\n    logger.info(f\"{path_groups=}, {basenames=}\")\n\n    with multiprocessing.get_context(\"spawn\").Pool(threads) as pool:\n        pool.starmap(\n            __hive_worker,\n            [(lf_group, basename, output_prefix, number_of_bits) for lf_group, basename in zip(lf_groups, basenames)],\n        )\n\n        pool.starmap(\n            __merge_file,\n            [(output_prefix / f\"id_part={id_part}\", basenames, append) for id_part in range(pow(2, number_of_bits))],\n        )\n</code></pre>"},{"location":"reference/variantplaner/struct/variants/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> variants","text":""},{"location":"reference/variantplaner/struct/variants/#variantplaner.struct.variants","title":"variants","text":"<p>Function relate to vcf structuration.</p> <p>Functions:</p> <ul> <li> <code>merge</code>             \u2013              <p>Perform merge of multiple parquet variants file in one file.</p> </li> </ul>"},{"location":"reference/variantplaner/struct/variants/#variantplaner.struct.variants.merge","title":"merge","text":"<pre><code>merge(\n    paths: list[Path],\n    output_prefix: Path,\n    memory_limit: int = 10000000000,\n    polars_threads: int = 4,\n    *,\n    append: bool\n) -&gt; None\n</code></pre> <p>Perform merge of multiple parquet variants file in one file.</p> <p>These function generate temporary file, by default file are written in <code>/tmp</code> but you can control where these files are written by set TMPDIR, TEMP or TMP directory.</p> <p>Parameters:</p> <ul> <li> <code>paths</code>               (<code>list[Path]</code>)           \u2013            <p>List of file you want chunked.</p> </li> <li> <code>output</code>           \u2013            <p>Path where variants is written.</p> </li> <li> <code>memory_limit</code>               (<code>int</code>, default:                   <code>10000000000</code> )           \u2013            <p>Size of each chunk in bytes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/variantplaner/struct/variants.py</code> <pre><code>def merge(\n    paths: list[pathlib.Path],\n    output_prefix: pathlib.Path,\n    memory_limit: int = 10_000_000_000,\n    polars_threads: int = 4,\n    *,\n    append: bool,\n) -&gt; None:\n    \"\"\"Perform merge of multiple parquet variants file in one file.\n\n    These function generate temporary file, by default file are written in `/tmp` but you can control where these files are written by set TMPDIR, TEMP or TMP directory.\n\n    Args:\n        paths: List of file you want chunked.\n        output: Path where variants is written.\n        memory_limit: Size of each chunk in bytes.\n\n    Returns:\n        None\n    \"\"\"\n    all_threads = int(os.environ[\"POLARS_MAX_THREADS\"])\n    multi_threads = max(all_threads // polars_threads, 1)\n    os.environ[\"POLARS_MAX_THREADS\"] = str(polars_threads)\n    output_prefix.mkdir(parents=True, exist_ok=True)\n\n    temp_prefix = pathlib.Path(tempfile.gettempdir()) / \"variantplaner\" / str(hash(output_prefix))\n    temp_prefix.mkdir(parents=True, exist_ok=True)\n\n    # merge file -&gt; split by chromosome perform unique\n    logger.debug(\"Start split first file\")\n    base_inputs_outputs: list[tuple[list[pathlib.Path], pathlib.Path]] = []\n    for input_chunk in __chunk_by_memory(paths, bytes_limit=memory_limit):\n        local_out_prefix = temp_prefix / str(hash(tuple(input_chunk)))\n        local_out_prefix.mkdir(parents=True, exist_ok=True)\n\n        base_inputs_outputs.append((input_chunk, local_out_prefix))\n\n    with multiprocessing.get_context(\"spawn\").Pool(multi_threads) as pool:\n        chr_names = set().union(*pool.starmap(__merge_split_unique, base_inputs_outputs))\n    logger.debug(\"End split first first file\")\n\n    if append and output_prefix.exists():\n        chr_names |= {entry.name.split(\".\")[0] for entry in os.scandir(output_prefix) if entry.is_file()}\n\n    # iterate over chromosme\n    logger.debug(\"Start merge by chromosome\")\n    for chr_name in chr_names:\n        logger.debug(f\"start chromosome: {chr_name}\")\n\n        chr_temp_prefix = temp_prefix / chr_name\n        chr_temp_prefix.mkdir(parents=True, exist_ok=True)\n\n        inputs = [\n            path / f\"{chr_name}.parquet\"\n            for (_, path) in base_inputs_outputs\n            if (path / f\"{chr_name}.parquet\").is_file()\n        ]\n\n        if append and (output_prefix / f\"{chr_name}.parquet\").exists():\n            inputs.append(output_prefix / f\"{chr_name}.parquet\")\n\n        if not inputs:\n            continue\n\n        while len(inputs) &gt; 1:\n            new_inputs = []\n\n            inputs_outputs = []\n            for input_chunk in __chunk_by_memory(inputs, bytes_limit=memory_limit):\n                logger.debug(f\"{input_chunk}\")\n                if len(input_chunk) == 1:\n                    new_inputs.append(input_chunk[0])\n                elif len(input_chunk) &gt; 1:\n                    temp_output = chr_temp_prefix / str(hash(tuple(input_chunk))) / f\"{chr_name}.parquet\"\n                    temp_output.parent.mkdir(parents=True, exist_ok=True)\n\n                    new_inputs.append(temp_output)\n                    inputs_outputs.append((input_chunk, temp_output))\n\n            inputs = new_inputs\n\n            with multiprocessing.get_context(\"spawn\").Pool(multi_threads) as pool:\n                pool.starmap(__merge_unique, inputs_outputs)\n\n        shutil.move(inputs[0], output_prefix / f\"{chr_name}.parquet\")\n        logger.debug(f\"end chromosome: {chr_name}\")\n    logger.debug(\"End merge by chromosome\")\n\n    # Call cleanup to remove all tempfile generate durring merging\n    logger.debug(\"Star clean tmp file\")\n    shutil.rmtree(temp_prefix, ignore_errors=True)\n    logger.debug(\"End clean tmp file\")\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}