{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ariantPlaner","text":"<p>A toolkit to manage many variants from many samples, with limited resources.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install git+https://github.com/SeqOIA-IT/variantplaner.git@0.4.1\n</code></pre> <p>With <code>uv</code>:</p> <pre><code>python -m pip install --user pipx\npipx install git+https://github.com/SeqOIA-IT/variantplaner.git@0.4.1\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>For usage exemple checkout usage page.</p>"},{"location":"#contribution","title":"Contribution","text":"<p>All contributions are welcome, see our \"How to contribute\" page.</p>"},{"location":"benchmark/","title":"Benchmark","text":"<p>Figure showing the performance of some variantplaner functions to check their complexity or compare certain features.</p> <pre><code>Traceback (most recent call last):\n  File \"/home/runner/work/variantplaner/variantplaner/.venv/lib/python3.12/site-packages/markdown_exec/_internal/formatters/python.py\", line 71, in _run_python\n    exec_python(code, code_block_id, exec_globals)\n  File \"/home/runner/work/variantplaner/variantplaner/.venv/lib/python3.12/site-packages/markdown_exec/_internal/formatters/_exec_python.py\", line 8, in exec_python\n    exec(compiled, exec_globals)  # noqa: S102\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"&lt;code block: n1&gt;\", line 14, in &lt;module&gt;\n    import altair\nModuleNotFoundError: No module named 'altair'\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#042-2025-04-15","title":"0.4.2 - 2025-04-15","text":"<p>Compare with 0.4.1</p>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>support compressed vcf with xopen (3310947)</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>remove debug instruction (dd93d54 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#041-2025-04-15","title":"0.4.1 - 2025-04-15","text":"<p>Compare with 0.4.0</p>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>try to avoid possible random error in int2string (5c7d40e by Pierre Marijon).</li> </ul>"},{"location":"changelog/#040-2025-04-10","title":"0.4.0 - 2025-04-10","text":"<p>Compare with 0.3.1</p>"},{"location":"changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>genotype samples_names perform unique sample (64e7274 by Pierre Marijon).</li> <li>improve struct variant tmp file naming (3119a40 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>rename variantplaner_rs in variantid and rewrite it (3961428 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#031-2024-12-16","title":"0.3.1 - 2024-12-16","text":"<p>Compare with 0.3.1</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>struct unique variant split variants by chromosome (ae7eb65 by Pierre Marijon).</li> <li>struct genotype polars threads parameter have an effect (6419e02 by Pierre Marijon).</li> <li>use new functionality of variantplaner_rs in variantplaner cli (f986213 by Pierre Marijon).</li> <li>variantplaner_rs partitions could be parameterize (8b2066e by Pierre Marijon).</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>use number of bit ask by user in partitions (4409d8c by Pierre Marijon).</li> <li>readd documentation generation (6467ee2 by Pierre Marijon).</li> <li>transmission generation not failled if ped file contain only one line (58ee926 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#030-2024-09-30","title":"0.3.0 - 2024-09-30","text":"<p>Compare with 0.2.4</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>move ped code from io to object (b6638ca by Pierre Marijon).</li> <li>parquet2vcf can extract only variant of one chromosome (f29c6ac by Pierre Marijon).</li> <li>improve alt '*' management (755a5fa by Pierre Marijon).</li> <li>partition support append mode (1b6603f by Pierre Marijon).</li> <li>variant merge support append (d12d357 by Pierre Marijon).</li> <li>Add python 3.12 in ci test and support (c51c932 by Pierre Marijon).</li> <li>Better variant hash we only need store ref length (8a3db5e by Pierre Marijon).</li> <li>add documentation on how interogate genotype variants partitions (b843bca by Pierre Marijon).</li> <li>New cli (c2cb033 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#bug-fixes_4","title":"Bug Fixes","text":"<ul> <li>add output file in struct operation only if it's exist (9a868ad by Pierre Marijon).</li> <li>not failled if SVTYPE or SVLEN column isn't present (32a8dad by Pierre Marijon).</li> <li>correct benchmark script run (8ebdca0 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Move many variant operation in object. (df36fa0 by Pierre Marijon).</li> </ul>"},{"location":"changelog/#024-2023-12-21","title":"0.2.4 - 2023-12-21","text":"<p>Compare with 0.2.4</p>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>add variantplaner logo.</li> <li>add method to compute partition value of id.</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"Bug Fixes","text":"<ul> <li>fix: #41 vcf spec indicate Integer must be store in 32bits.</li> <li>update to polars 0.20.</li> </ul>"},{"location":"changelog/#023-2023-11-21","title":"0.2.3 - 2023-11-21","text":"<p>Compare with 0.2.2</p>"},{"location":"changelog/#features_4","title":"Features:","text":"<ul> <li>Use ruff format in place of black</li> <li>Minimal polars version is 0.19.15</li> <li>SV cannot have small variant id</li> <li>Type of id is include in part of id (all long variant are store in same place)</li> </ul>"},{"location":"changelog/#fix","title":"Fix:","text":"<ul> <li>Usage intgerate chromosome2length option</li> </ul>"},{"location":"changelog/#022-2023-10-19","title":"0.2.2 - 2023-10-19","text":"<p>Compare with first 0.2.0</p>"},{"location":"changelog/#fix_1","title":"Fix:","text":"<ul> <li>Correct typo in readme</li> <li>Correct change in variantplaner_rs/Cargo.lock</li> </ul>"},{"location":"changelog/#021-2023-10-09","title":"0.2.1 - 2023-10-09","text":"<p>Compare with first 0.2.0</p>"},{"location":"changelog/#fix_2","title":"Fix:","text":"<ul> <li>Hot fix some lazy trouble</li> </ul>"},{"location":"changelog/#020-2023-10-02","title":"0.2.0 - 2023-10-02","text":"<p>Compare with first 0.1.0</p>"},{"location":"changelog/#features_5","title":"Features:","text":"<ul> <li>Replace hash variant id by a uniq variant id</li> <li>Improve variant transmission system to support genome with ploidie lower than 92</li> <li>Genotype partitioning now use position part of unique id to get more local request</li> </ul>"},{"location":"changelog/#fixes","title":"Fixes:","text":"<ul> <li>Documentation fix</li> <li>Test coverage improvement</li> </ul>"},{"location":"changelog/#010-2023-07-25","title":"0.1.0 - 2023-07-25","text":"<p>Compare with first commit</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pierre.marijon-ext@aphp.fr. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Note</p> <p> Usage of pyenv is recommended</p> <p>After install pyenv run: <pre><code>pyenv install 3.9 3.10 3.11\n</code></pre></p> <p>Fork and clone the repository, then:</p> <pre><code>cd variantplaner\nmake setup\n</code></pre> <p>Note</p> <p>If it fails for some reason, you'll need to install uv manually.</p> <p>You can install it with:</p> <pre><code>python3 -m pip install --user pipx\npipx install uv\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>uv sync</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>uv run variantplaner [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>The entry-point to run commands and tasks is the <code>make</code> Python script, located in the <code>scripts</code> directory. Try running <code>make</code> to show the available commands and tasks. The commands do not need the Python dependencies to be installed, while the tasks do. The cross-platform tasks are written in Python, thanks to duty.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":"<pre><code>    # Credits\n\n    These projects were used to build *variantplaner*. **Thank you!**\n\n    [Python](https://www.python.org/) |\n    [uv](https://github.com/astral-sh/uv) |\n    [copier-uv](https://github.com/pawamoy/copier-uv)\n\n    {% macro dep_line(dep) -%}\n    [{{ dep.name }}](https://pypi.org/project/{{ dep.name }}/) | {{ dep.summary }} | {{ (\"`\" ~ dep.spec|sort(reverse=True)|join(\", \") ~ \"`\") if dep.spec else \"\" }} | `{{ dep.version }}` | {{ dep.license }}\n    {%- endmacro %}\n\n    {% if prod_dependencies -%}\n    ### Runtime dependencies\n\n    Project | Summary | Version (accepted) | Version (last resolved) | License\n    ------- | ------- | ------------------ | ----------------------- | -------\n    {% for dep in prod_dependencies -%}\n    {{ dep_line(dep) }}\n    {% endfor %}\n\n    {% endif -%}\n    {% if dev_dependencies -%}\n    ### Development dependencies\n\n    Project | Summary | Version (accepted) | Version (last resolved) | License\n    ------- | ------- | ------------------ | ----------------------- | -------\n    {% for dep in dev_dependencies -%}\n    {{ dep_line(dep) }}\n    {% endfor %}\n\n    {% endif -%}\n</code></pre>"},{"location":"license/","title":"License","text":"<pre><code>MIT License\n\nCopyright (c) 2025 GCS SeqOIA\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n</code></pre>"},{"location":"usage/","title":"VariantPlaner","text":"<p>variantplaner is a set of tools that converts a large set of vcf's into an interoperable data structure efficiently.</p> <p>To show the capabilities of the <code>variantplaner</code>, we will use a small example.</p> <p>The purpose of this short tutorial is to present:</p> <ul> <li>how to convert vcf into a more suitable format</li> <li>how data can be restructured for querying</li> <li>how to integrate variant annotation databases</li> <li>how these different files can be used to obtain interesting biological information</li> </ul> <p>This tutorial suggests an organization of files, but you're under no obligation to follow it <code>variantplaner</code> is quite flexible in its organization.</p>"},{"location":"usage/#setup","title":"Setup","text":"<p>This tutorial assume you are on unix like system, you have python setup and you install variantplaner</p> <p>Requirements list:</p> <ul> <li>curl</li> <li>gunzip</li> <li>pqrs (only for transmission computation, otherwise optional)</li> </ul> <p>Optional:</p> <ul> <li>gnu-parallel</li> </ul> <p>Quering dataset:</p> <ul> <li>polars-cli</li> <li>duckdb</li> </ul>"},{"location":"usage/#download-data","title":"Download data","text":"<pre><code>mkdir -p vp_tuto/vcf/\ncd vp_tuto\nURI_ROOT=\"https://ftp-trace.ncbi.nlm.nih.gov/ReferenceSamples/giab/release\"\ncurl ${URI_ROOT}/NA12878_HG001/latest/GRCh38/HG001_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG001.vcf\ncurl ${URI_ROOT}/AshkenazimTrio/HG002_NA24385_son/latest/GRCh38/HG002_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG002.vcf\ncurl ${URI_ROOT}/AshkenazimTrio/HG003_NA24149_father/latest/GRCh38/HG003_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG003.vcf\ncurl ${URI_ROOT}/AshkenazimTrio/HG004_NA24143_mother/latest/GRCh38/HG004_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG004.vcf\ncurl ${URI_ROOT}/ChineseTrio/HG006_NA24694_father/latest/GRCh38/HG006_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG006.vcf\ncurl ${URI_ROOT}/ChineseTrio/HG007_NA24695_mother/latest/GRCh38/HG007_GRCh38_1_22_v4.2.1_benchmark.vcf.gz | gunzip - &gt; vcf/HG007.vcf\n</code></pre>"},{"location":"usage/#variant-planner-presentation","title":"Variant planner presentation","text":"<p>variantplaner is a python module with command line tools, it is composed of several subcommands (they will be detailed later) but has two global options, one for parallelization and another for the level of verbosity you want.</p> <pre><code>Usage: variantplaner [OPTIONS] COMMAND [ARGS]...\n\n  Run VariantPlanner.\n\nOptions:\n  -t, --threads INTEGER RANGE  Number of threads usable  [default: 1; x&gt;=0]\n  -v, --verbose                Verbosity level  [0&lt;=x&lt;=4]\n  --debug-info                 Get debug information\n  -h, --help                   Show this message and exit.\n\nCommands:\n  metadata      Convert metadata file in parquet file.\n  parquet2vcf   Convert variant parquet in vcf.\n  struct        Subcommand to made struct operation on parquet file.\n  transmission  Generate transmission of a genotype set.\n  vcf2parquet   Convert a vcf in parquet.\n</code></pre>"},{"location":"usage/#vcf2parquet","title":"vcf2parquet","text":"<p>First step is to convert vcf data in parquet, it's a column oriented format with better performance than indexed vcf.</p> <p>We split vcf in two part on for variant information and another for genotype information.</p> <pre><code>mkdir -p variants genotypes/samples/\n</code></pre> <pre><code>for vcf_path in $(ls vcf/*.vcf)\ndo\n    sample_name=$(basename ${vcf_path} .vcf)\n    variantplaner -t 4 vcf2parquet -i ${vcf_path} \\\n    -c grch38.92.csv \\\n    variants -o variants/${sample_name}.parquet \\\n    genotypes -o genotypes/samples/${sample_name}.parquet \\\n    -f GT:PS:DP:ADALL:AD:GQ\ndone\n</code></pre> <p>We iterate over all vcf, variants are store in <code>variants/{sample_name}.parquet</code>, genotype information are store in <code>variants/{sample_name}.parquet</code>. Only genotypes with a format value equal to the <code>-f</code> parameter value are retained.</p> gnu-parallel method <pre><code>find vcf -type f -name *.vcf -exec basename {} .vcf \\; | \\\nparallel variantplaner -t 2 vcf2parquet -c grch38.92.csv -i vcf/{}.vcf \\\nvariants -o variants/{}.parquet genotypes -o genotypes/samples/{}.parquet -f GT:PS:DP:ADALL:AD:GQ\n</code></pre> <p>Parquet variants file contains 5 column:</p> <ul> <li>pos: Position of variant</li> <li>ref: Reference sequence</li> <li>alt: Alternative sequence</li> <li>id: An hash of other value collision isn't check but highly improbable check api documentation</li> </ul> variants parquet file content <p>You can inspect content of parquet file generate with pqrs <pre><code>pqrs head variants/HG001.parquet\n{id: 17886044532216650390, chr: 1, pos: 783006, ref: \"A\", alt: \"G\"}\n{id: 7513336577790240873, chr: 1, pos: 783175, ref: \"T\", alt: \"C\"}\n{id: 17987040642944149052, chr: 1, pos: 784860, ref: \"T\", alt: \"C\"}\n{id: 10342734968077036194, chr: 1, pos: 785417, ref: \"G\", alt: \"A\"}\n{id: 890514037559296207, chr: 1, pos: 797392, ref: \"G\", alt: \"A\"}\n</code></pre></p> <p>Parquet genotypes file contains column:</p> <ul> <li>id: Same as variant id</li> <li>gt: vcf GT value 1 -&gt; heterozygote 2 -&gt; homozygote (phasing information is lost)</li> <li>ps: Phase set in which this variant falls</li> <li>dp: vcf DP coverage of the variant for this sample</li> <li>adall: Net allele depths across all datasets</li> <li>ad: vcf AD per allele reads depth</li> <li>gq: vcf GQ quality of variant for this sample</li> </ul> genotypes parquet file content <p>You can inspect content of parquet file generate with pqrs <pre><code>pqrs head genotypes/samples/HG001.parquet\n{id: 17886044532216650390, sample: \"HG001\", gt: 2, ps: null, dp: 652, adall: [16, 234], ad: [0, 82], gq: 312}\n{id: 7513336577790240873, sample: \"HG001\", gt: 2, ps: null, dp: 639, adall: [0, 218], ad: [0, 84], gq: 194}\n{id: 17987040642944149052, sample: \"HG001\", gt: 2, ps: null, dp: 901, adall: [105, 406], ad: [0, 74], gq: 301}\n{id: 10342734968077036194, sample: \"HG001\", gt: 2, ps: null, dp: 820, adall: [125, 383], ad: [0, 70], gq: 339}\n{id: 890514037559296207, sample: \"HG001\", gt: 1, ps: null, dp: 760, adall: [161, 142], ad: [25, 37], gq: 147}\n</code></pre></p>"},{"location":"usage/#structuration-of-data","title":"Structuration of data","text":""},{"location":"usage/#merge-all-variant","title":"Merge all variant","text":"<p>We can now aggregate all variant present in our dataset to perform this operation we use divide to conquer merge method by generate temporary file. By default, file are written in <code>/tmp</code> but you can control where these files are written by set <code>TMPDIR</code>, <code>TEMP</code> or <code>TMP</code> directory.</p> <pre><code>variantplaner -t 8 struct -i variants/*.parquet -- variants -o variants.parquet\n</code></pre> <p>File <code>variants.parquet</code> contains all unique variants present in dataset, <code>--</code> after last input path are mandatory.</p>"},{"location":"usage/#genotypes-structuration","title":"Genotypes structuration","text":""},{"location":"usage/#by-samples","title":"By samples","text":"<p>This structurations data is already down in vcf2parquet step check content of <code>genotypes/samples</code>: <pre><code>\u279c ls genotypes/samples\nHG001.parquet  HG002.parquet  HG003.parquet  HG004.parquet  HG006.parquet  HG007.parquet\n</code></pre></p>"},{"location":"usage/#by-variants","title":"By variants","text":"<p>Here, we'll organize the genotypes information by variants to make it easier to find samples where a variant is present or not.</p> <pre><code>mkdir -p genotypes/variants/\nvariantplaner -t 8 struct -i genotypes/samples/*.parquet -- genotypes -p genotypes/variants\n</code></pre> <p>All genotypes information are split in hive like structure to optimize request on data, <code>--</code> after last input path are mandatory.</p>"},{"location":"usage/#compute-transmission-mode","title":"Compute transmission mode","text":"<p>If you are working with families, <code>variantplaner</code> can calculate the modes of transmission of the variants.</p> <p>For these step, we need to concatenate all genotypes of a AshkenazimTrio in one parquet sample.</p> <pre><code>pqrs merge -i genotypes/samples/HG002.parquet genotypes/samples/HG003.parquet genotypes/samples/HG004.parquet -o genotypes/samples/AshkenazimTrio.parquet\nmkdir -p genotypes/transmissions/\nvariantplaner transmission -g genotypes/samples/AshkenazimTrio.parquet -i HG002 -m HG003 -f HG004 -o genotypes/transmissions/AshkenazimTrio.parquet\n</code></pre> <p><code>-I</code> parameter is use for index sample, <code>-m</code> parameter is use for mother sample, <code>-f</code> parameter is use for father sample only the index sample is mandatory if mother sample or father sample isn't present command work, you could also use a pedigree file with parameter <code>-p</code>.</p> transmission parquet file content <pre><code>{id: 10201716324449815219, index_gt: 2, index_ps: null, index_dp: 1066, index_adall: [0, 284], index_ad: [118, 586], index_gq: 598, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"#~~\"}\n{id: 8292180701257594706, index_gt: 1, index_ps: null, index_dp: 1122, index_adall: [177, 165], index_ad: [310, 283], index_gq: 556, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n{id: 1728452411043401356, index_gt: 1, index_ps: null, index_dp: 1365, index_adall: [225, 222], index_ad: [348, 380], index_gq: 658, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n{id: 4237549706021671868, index_gt: 1, index_ps: null, index_dp: 1019, index_adall: [154, 153], index_ad: [277, 282], index_gq: 517, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n{id: 1361753917441299167, index_gt: 1, index_ps: null, index_dp: 1033, index_adall: [159, 170], index_ad: [265, 273], index_gq: 552, mother_gt: null, mother_ps: null, mother_dp: null, mother_adall: null, mother_ad: null, mother_gq: null, father_gt: null, father_ps: null, father_dp: null, father_adall: null, father_ad: null, father_gq: null, origin: \"\"~~\"}\n</code></pre> <p>Parquet transmissions file contains column all genotypes information with suffix <code>_index</code>, <code>_mother</code> and <code>_father</code> plus a <code>origin</code> column</p> <p>Origin column contains a string with 3 character:</p> <pre><code>#~\"\n\u2502\u2502\u2514 ASCII_value_of(father genotype + 33)\n\u2502\u2514\u2500 ASCII_value_of(mother genotype + 33)\n\u2514\u2500\u2500 ASCII_value_of(index genotype  + 33)\n</code></pre> <p>In this example case, variants is homozygotes in index, mother information is missing, variants is heterozygotes in father.</p> <p>Maximal genotype value is 92, which corresponds to the character <code>}</code>, <code>~</code> match with value 93, this value also mean unknow genotype.</p>"},{"location":"usage/#add-annotations","title":"Add annotations","text":"<p>To work on your variant, you probably need variants annotations.</p>"},{"location":"usage/#snpeff-annotations","title":"Snpeff annotations","text":"<p>First convert your unique variants in parquet format (<code>variants.parquet</code>) in vcf: <pre><code>variantplaner -t 8 parquet2vcf -i variants.parquet -o variants.vcf\n</code></pre></p> <p><code>parquet2vcf</code> subcommand have many more options but we didn't need it now.</p> <p>Next annotate this <code>variants.vcf</code> with snpeff, we assume you generate a file call <code>variants.snpeff.vcf</code>.</p> <p>To convert annotated vcf in parquet, keep 'ANN' info column and rename vcf id column in snpeff_id you can run: <pre><code>mkdir -p annotations\nvariantplaner -t 8 vcf2parquet -c grch38.92.csv -i variants.snpeff.vcf annotations -o annotations/snpeff.parquet vcf -i ANN -r snpeff_id\n</code></pre></p> <p>If you didn't set any value of option <code>-i</code> in vcf subsubcommand all info column are keep.</p>"},{"location":"usage/#clinvar-annotations","title":"Clinvar annotations","text":"<p>Download last clinvar version:</p> <pre><code>mkdir -p annotations\ncurl https://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh38/clinvar.vcf.gz \\\n| gunzip - &gt; annotations/clinvar.vcf\n</code></pre> <p>Because clinvar's vcf file header does not contain information on contigs, you should create file <code>grch38.92.csv</code> with this content: <pre><code>contig,length\nchr1,248956422\nchr10,133797422\nchr11,135086622\nchr12,133275309\nchr13,114364328\nchr14,107043718\nchr15,101991189\nchr16,90338345\nchr17,83257441\nchr18,80373285\nchr19,58617616\nchr2,242193529\nchr20,64444167\nchr21,46709983\nchr22,50818468\nchr3,198295559\nchr4,190214555\nchr5,181538259\nchr6,170805979\nchr7,159345973\nchr8,145138636\nchr9,138394717\nchrMT,16569\nchrX,156040895\nchrY,57227415\n</code></pre></p> <p>Convert clinvar vcf file in parquet file:</p> <pre><code>variantplaner vcf2parquet -c grch38.92.csv -i annotations/clinvar.vcf annotations -o annotations/clinvar.parquet -r clinvar_id\n</code></pre> <p>Parquet file produce contains many columns:</p> <ul> <li>clinvar_id: content of vcf id column if option <code>-r</code> is not set, column name is <code>vid</code></li> <li>id: variantplaner id</li> <li>All INFO filed</li> </ul> <p>Annotations subcommand try to make match between vcf info type and parquet type.</p> <code>annotations/clinvar.parquet</code> file content <pre><code>pqrs head annotations/clinvar.parquet\n{clinvar_id: 2205837, id: 11650605831284591550, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2193183, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69134A&gt;G\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Likely_benign\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2252161, id: 2295086632353399847, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2238986, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69581C&gt;G\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2396347, id: 11033100074712141168, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2386655, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69682G&gt;A\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2288999, id: 10487392163259126218, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2278803, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69769T&gt;C\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n{clinvar_id: 2351346, id: 5356120651941363990, AF_ESP: null, AF_EXAC: null, AF_TGP: null, ALLELEID: 2333177, CLNDN: [\"Inborn_genetic_diseases\"], CLNDNINCL: null, CLNDISDB: [\"MeSH:D030342\", \"MedGen:C0950123\"], CLNDISDBINCL: null, CLNHGVS: [\"NC_000001.11:g.69995G&gt;C\"], CLNREVSTAT: [\"criteria_provided\", \"_single_submitter\"], CLNSIG: [\"Uncertain_significance\"], CLNSIGCONF: null, CLNSIGINCL: null, CLNVC: \"single_nucleotide_variant\", CLNVCSO: \"SO:0001483\", CLNVI: null, DBVARID: null, GENEINFO: \"OR4F5:79501\", MC: [\"SO:0001583|missense_variant\"], ORIGIN: [\"1\"], RS: null}\n</code></pre> <p>With option of subcommand vcf <code>-i</code> you can select which column are included in parquet file For example command: <pre><code>variantplaner vcf2parquet -c grch38.92.csv -i annotations/clinvar.vcf annotations -o annotations/clinvar.parquet -r clinvar_id -i ALLELEID -i CLNDN -i AF_ESP -i GENEINFO\n</code></pre></p> <p>Produce a <code>annotations/clinvar.parquet</code> with columns:</p> <ul> <li>clinvar_id</li> <li>id</li> <li>ALLELEID</li> <li>CLNDN</li> </ul> <code>annotations/clinvar.parquet</code> file content <pre><code>\u279c pqrs head annotations/clinvar.parquet\n{clinvar_id: 2205837, id: 11650605831284591550, ALLELEID: 2193183, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2252161, id: 2295086632353399847, ALLELEID: 2238986, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2396347, id: 11033100074712141168, ALLELEID: 2386655, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2288999, id: 10487392163259126218, ALLELEID: 2278803, CLNDN: [\"Inborn_genetic_diseases\"]}\n{clinvar_id: 2351346, id: 5356120651941363990, ALLELEID: 2333177, CLNDN: [\"Inborn_genetic_diseases\"]}\n</code></pre>"},{"location":"usage/#split-snpeff-annotations-in-parquet-column","title":"Split snpeff annotations in parquet column","text":"<p>After annotate your vcf with snpeff in <code>ann</code> mode and write result in file <code>snpeff_annotations.vcf</code> you could run a script similar to this to generate <code>snpeff_annotations.parquet</code>: <pre><code>from variantplaner import Vcf\n\nvcf = Vcf()\ntry:\n    vcf.from_path(\"snpeff_annotations.vcf\", \"grch38.92.csv\")\nexcept variantplaner.exception.NotAVCFError:\n    print(\"snpeff_annotations.vcf seems to have error\")\n    return 1\nexcept variantplaner.exception.NoContigsLengthInformationError:\n    print(\"snpeff_annotations.vcf header seems not contain contig information\")\n    return 2\n\nlf = vcf.lf.with_columns(vcf.header.info_parser())\nlf = lf.drop([\"chr\", \"pos\", \"ref\", \"alt\", \"filter\", \"qual\", \"info\"])\nlf = lf.rename({\"vid\": \"id\"})\nlf = lf.explode(\"ANN\")\nlf = lf.cast({\"id\": polars.UInt64})\n\nlf = lf.with_columns(\n    [\n        polars.col(\"ANN\")\n        .list.get(0)\n        .str.split(\"|\")\n        .cast(polars.List(polars.Utf8()))\n        .alias(\"ann\"),\n    ]\n).drop(\"ANN\")\n\nlf = lf.with_columns(\n    [\n        polars.col(\"ann\").list.get(1).alias(\"effect\"),\n        polars.col(\"ann\").list.get(2).alias(\"impact\"),\n        polars.col(\"ann\").list.get(3).alias(\"gene\"),\n        polars.col(\"ann\").list.get(4).alias(\"geneid\"),\n        polars.col(\"ann\").list.get(5).alias(\"feature\"),\n        polars.col(\"ann\").list.get(6).alias(\"feature_id\"),\n        polars.col(\"ann\").list.get(7).alias(\"bio_type\"),\n        polars.col(\"ann\").list.get(8).alias(\"rank\"),\n        polars.col(\"ann\").list.get(9).alias(\"hgvs_c\"),\n        polars.col(\"ann\").list.get(10).alias(\"hgvs_p\"),\n        polars.col(\"ann\").list.get(11).alias(\"cdna_pos\"),\n        polars.col(\"ann\").list.get(12).alias(\"cdna_len\"),\n        polars.col(\"ann\").list.get(13).alias(\"cds_pos\"),\n        polars.col(\"ann\").list.get(14).alias(\"cvs_len\"),\n        polars.col(\"ann\").list.get(15).alias(\"aa_pos\"),\n    ]\n).drop(\"ann\")\n\nlf.sink_parquet(\"snpeff_annotations.parquet\")\n</code></pre></p>"},{"location":"usage/#querying","title":"Querying","text":"<p>You can use any tool or software library supporting the parquet format to use the files generated by <code>variantplaner</code>.</p> <p>We show you how to use files with polars-cli and duckdb.</p>"},{"location":"usage/#polars-cli","title":"polars-cli","text":""},{"location":"usage/#count-variants","title":"Count variants","text":"<pre><code>\u3009select count(*) from read_parquet('variants.parquet');\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 count   \u2502\n\u2502 ---     \u2502\n\u2502 u32     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 7852699 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> check result with <code>pqrs</code> <p>We can check we have same result with pqrs</p> <pre><code>\u279c pqrs rowcount variants.parquet\nFile Name: variants.parquet: 7852699 rows\n</code></pre>"},{"location":"usage/#filter-variants-from-annotations","title":"Filter variants from annotations:","text":"<p>Get all variant with a AF_ESP upper than 0.9999</p> <pre><code>\u3009select chr, pos, ref, alt, AF_ESP from read_parquet('variants.parquet') as v left join read_parquet('annotations/clinvar.parquet') as c on c.id=v.id where AF_ESP&gt;0.9999;\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 chr \u2506 pos      \u2506 ref \u2506 alt \u2506 AF_ESP  \u2502\n\u2502 --- \u2506 ---      \u2506 --- \u2506 --- \u2506 ---     \u2502\n\u2502 u8  \u2506 u64      \u2506 str \u2506 str \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10  \u2506 16901372 \u2506 G   \u2506 C   \u2506 0.99992 \u2502\n\u2502 11  \u2506 78121030 \u2506 T   \u2506 A   \u2506 0.99992 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#get-sample-have-variant","title":"Get sample have variant","text":"<p>Get all variant and sample with GENEINFO equal to 'SAMD11:148398'</p> <pre><code>\u3009select distinct chr, pos, ref, alt, sample from read_parquet('variants.parquet') as v left join read_parquet('genotypes/samples/*') as g on v.id=g.id left join read_parquet('annotations/clinvar.parquet') as a on v.id=a.id WHERE GENEINFO='SAMD11:148398';\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 chr \u2506 pos    \u2506 ref \u2506 alt \u2506 sample \u2502\n\u2502 --- \u2506 ---    \u2506 --- \u2506 --- \u2506 ---    \u2502\n\u2502 u8  \u2506 u64    \u2506 str \u2506 str \u2506 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG003  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG001  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG007  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG004  \u2502\n\u2502 \u2026   \u2506 \u2026      \u2506 \u2026   \u2506 \u2026   \u2506 \u2026      \u2502\n\u2502 1   \u2506 942934 \u2506 G   \u2506 C   \u2506 HG003  \u2502\n\u2502 1   \u2506 943937 \u2506 C   \u2506 T   \u2506 HG004  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG002  \u2502\n\u2502 1   \u2506 942451 \u2506 T   \u2506 C   \u2506 HG006  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#duckdb","title":"duckdb","text":""},{"location":"usage/#count-variants_1","title":"Count variants","text":"<pre><code>D select count(*) from read_parquet('variants.parquet');\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 count_star() \u2502\n\u2502    int64     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502      7852699 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> check result with <code>pqrs</code> <p>We can check we have same result with pqrs</p> <pre><code>\u279c pqrs rowcount variants.parquet\nFile Name: variants.parquet: 7852699 rows\n</code></pre>"},{"location":"usage/#filter-variants-from-annotations_1","title":"Filter variants from annotations:","text":"<p>Get all variant with a AF_ESP upper than 0.9999</p> <pre><code>D select chr, pos, ref, alt, AF_ESP from read_parquet('variants.parquet') as v left join read_parquet('annotations/clinvar.parquet') as c on c.id=v.id where AF_ESP&gt;0.9999;\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  chr  \u2502   pos    \u2502   ref   \u2502   alt   \u2502 AF_ESP  \u2502\n\u2502 uint8 \u2502  uint64  \u2502 varchar \u2502 varchar \u2502 double  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    10 \u2502 16901372 \u2502 G       \u2502 C       \u2502 0.99992 \u2502\n\u2502    11 \u2502 78121030 \u2502 T       \u2502 A       \u2502 0.99992 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#get-sample-have-variant_1","title":"Get sample have variant","text":"<p>Get all variant and sample with GENEINFO equal to 'SAMD11:148398'</p> <pre><code>D select distinct chr, pos, ref, alt, sample from read_parquet('variants.parquet') as v left join read_parquet('genotypes/samples/*') as g on v.id=g.id left join read_parquet('annotations/clinvar.parquet') as a on v.id=a.id WHERE GENEINFO='SAMD11:148398';\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  chr  \u2502  pos   \u2502   ref   \u2502   alt   \u2502 sample  \u2502\n\u2502 uint8 \u2502 uint64 \u2502 varchar \u2502 varchar \u2502 varchar \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG002   \u2502\n\u2502     1 \u2502 942934 \u2502 G       \u2502 C       \u2502 HG002   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG003   \u2502\n\u2502     1 \u2502 942934 \u2502 G       \u2502 C       \u2502 HG003   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG007   \u2502\n\u2502     1 \u2502 943937 \u2502 C       \u2502 T       \u2502 HG007   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG001   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG004   \u2502\n\u2502     1 \u2502 943937 \u2502 C       \u2502 T       \u2502 HG004   \u2502\n\u2502     1 \u2502 942451 \u2502 T       \u2502 C       \u2502 HG006   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 10 rows                            5 columns \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"usage/#use-genotype-partition","title":"Use genotype partition","text":"<p>In this example, I'll show how I interact with the data structures created by variantplaner.</p>"},{"location":"usage/#import","title":"Import","text":"<pre><code>import duckdb\nimport polars\nimport variantplaner\n</code></pre>"},{"location":"usage/#get-variants","title":"Get variants","text":"<pre><code>query = f\"\"\"\nSELECT\n  *\nFROM\n  read_parquet('variants.parquet') as v\nWHERE\n  v.chr == '19'\n\"\"\"\n\nvariants = duckdb.query(query).pl()\n</code></pre>"},{"location":"usage/#add-annotations_1","title":"Add annotations","text":"<pre><code>query = f\"\"\"\nSELECT\n  v.*, c.CLNSIG\nFROM\n  variants as v\n  JOIN\n  read_parquet('annotations/clinvar.parquet') as c\n  ON\n  v.id == c.id\nWHERE\n  c.CLNSIG LIKE '%Patho%'\n\"\"\"\n\nannotations = duckdb.query(query).pl()\n</code></pre>"},{"location":"usage/#add-genotypes","title":"Add genotypes","text":"<pre><code>def worker(name_data: (str, polars.DataFrame)) -&gt; polars.DataFrame:\n    \"\"\"Request genotype homozygote variant.\"\"\"\n    name, data = name_data\n    query = f\"\"\"\nSELECT\n  data.*, g.*,\nFROM\n  data\n  JOIN\n  read_parquet('genotypes/variants/id_part={name}/0.parquet') as g ON data.id = g.id\nWHERE\n  g.gt == 2\n\"\"\"\n    df = duckdb.query(query).pl()\n    return df\n\n\nannotations = variantplaner.normalization.add_id_part(annotations)\n\nall_genotypes = []\n\nfor data in map(worker, annotations.group_by(by=\"id_part\")):\n    if data is not None:\n        all_genotypes.append(data)\n\ngenotypes = polars.concat(all_genotypes)\n</code></pre> <p>genotypes is polars.DataFrame with pathogene homozygote variants in chromosome 19.</p>"},{"location":"reference/api/","title":"API reference","text":""},{"location":"reference/api/#variantplaner","title":"variantplaner","text":"<p>VariantPlaner, a tool kit to manage many variants without many cpu and ram resource.</p> <p>Convert a vcf in parquet, convert annotations in parquet, convert parquet in vcf.</p> <p>But also build a file struct to get a fast variant database interrogations time.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Module contains command line entry point function.</p> </li> <li> <code>exception</code>           \u2013            <p>Exception could be generate by VariantPlanner.</p> </li> <li> <code>extract</code>           \u2013            <p>Extract information of polars.LazyFrame produce from raw vcf file parsing.</p> </li> <li> <code>generate</code>           \u2013            <p>Function to generate information.</p> </li> <li> <code>io</code>           \u2013            <p>Module manage input parsing and output serializing.</p> </li> <li> <code>normalization</code>           \u2013            <p>Function use to normalize data.</p> </li> <li> <code>objects</code>           \u2013            <p>Module to store variantplaner object.</p> </li> <li> <code>struct</code>           \u2013            <p>Generated data structures for easy integration.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Annotations</code>           \u2013            <p>Object to manage lazyframe as Annotations.</p> </li> <li> <code>ContigsLength</code>           \u2013            <p>Store contigs -&gt; length information.</p> </li> <li> <code>Genotypes</code>           \u2013            <p>Object to manage lazyframe as Genotypes.</p> </li> <li> <code>Pedigree</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> <li> <code>Variants</code>           \u2013            <p>Object to manage lazyframe as Variants.</p> </li> <li> <code>Vcf</code>           \u2013            <p>Object to manage lazyframe as Vcf.</p> </li> <li> <code>VcfHeader</code>           \u2013            <p>Object that parse and store vcf information.</p> </li> <li> <code>VcfParsingBehavior</code>           \u2013            <p>Enumeration use to control behavior of IntoLazyFrame.</p> </li> </ul>"},{"location":"reference/api/#variantplaner.Annotations","title":"Annotations","text":"<pre><code>Annotations()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Annotations.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Annotations object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Annotations.minimal_schema())\n</code></pre>"},{"location":"reference/api/#variantplaner.Annotations.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/annotations.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n    }\n</code></pre>"},{"location":"reference/api/#variantplaner.ContigsLength","title":"ContigsLength","text":"<pre><code>ContigsLength()\n</code></pre> <p>Store contigs -&gt; length information.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Fill object with file point by pathlib.Path.</p> </li> <li> <code>from_vcf_header</code>             \u2013              <p>Fill a object with VcfHeader.</p> </li> </ul> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise a contigs length.\"\"\"\n    self.lf = polars.LazyFrame(\n        schema={\n            \"contig\": polars.String,\n            \"length\": polars.UInt64,\n            \"offset\": polars.UInt64,\n        }\n    )\n</code></pre>"},{"location":"reference/api/#variantplaner.ContigsLength.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path, /, **scan_csv_args: Unpack[ScanCsv]\n) -&gt; int\n</code></pre> <p>Fill object with file point by pathlib.Path.</p> <p>Argument: path: path of input file</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_path(self, path: pathlib.Path, /, **scan_csv_args: Unpack[ScanCsv]) -&gt; int:\n    \"\"\"Fill object with file point by pathlib.Path.\n\n    Argument:\n    path: path of input file\n\n    Returns: Number of contigs line view\n    \"\"\"\n    csv = Csv()\n    csv.from_path(path, **scan_csv_args)\n    self.lf = csv.lf\n\n    self.__compute_offset()\n\n    return self.lf.collect(engine=\"cpu\").shape[0]\n</code></pre>"},{"location":"reference/api/#variantplaner.ContigsLength.from_vcf_header","title":"from_vcf_header","text":"<pre><code>from_vcf_header(header: VcfHeader) -&gt; int\n</code></pre> <p>Fill a object with VcfHeader.</p> Argument <p>header: VcfHeader</p> <p>Returns: Number of contigs line view</p> Source code in <code>src/variantplaner/objects/contigs_length.py</code> <pre><code>def from_vcf_header(self, header: VcfHeader) -&gt; int:\n    \"\"\"Fill a object with VcfHeader.\n\n    Argument:\n       header: VcfHeader\n\n    Returns: Number of contigs line view\n    \"\"\"\n    contigs_id = re.compile(r\"ID=(?P&lt;id&gt;[^,]+)\")\n    contigs_len = re.compile(r\"length=(?P&lt;length&gt;[^,&gt;]+)\")\n\n    count = 0\n    contigs2len: dict[str, list] = {\"contig\": [], \"length\": []}\n    for contig_line in header.contigs:\n        if (len_match := contigs_len.search(contig_line)) and (id_match := contigs_id.search(contig_line)):\n            contigs2len[\"contig\"].append(id_match.groupdict()[\"id\"])\n            contigs2len[\"length\"].append(int(len_match.groupdict()[\"length\"]))\n        count += 1\n\n    self.lf = polars.LazyFrame(contigs2len, schema={\"contig\": polars.String, \"length\": polars.UInt64})\n\n    self.__compute_offset()\n\n    return count\n</code></pre>"},{"location":"reference/api/#variantplaner.Genotypes","title":"Genotypes","text":"<pre><code>Genotypes(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Genotypes.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get minimal schema of genotypes polars.LazyFrame.</p> </li> <li> <code>samples_names</code>             \u2013              <p>Get list of sample name.</p> </li> </ul> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Genotypes object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Genotypes.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/api/#variantplaner.Genotypes.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get minimal schema of genotypes polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get minimal schema of genotypes polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"sample\": polars.String,\n    }\n</code></pre>"},{"location":"reference/api/#variantplaner.Genotypes.samples_names","title":"samples_names","text":"<pre><code>samples_names() -&gt; list[str]\n</code></pre> <p>Get list of sample name.</p> Source code in <code>src/variantplaner/objects/genotypes.py</code> <pre><code>def samples_names(self) -&gt; list[str]:\n    \"\"\"Get list of sample name.\"\"\"\n    return self.lf.select(\"sample\").unique(\"sample\").collect(engine=\"cpu\").get_column(\"sample\").to_list()\n</code></pre>"},{"location":"reference/api/#variantplaner.Pedigree","title":"Pedigree","text":"<pre><code>Pedigree()\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>from_path</code>             \u2013              <p>Read a pedigree file in polars.LazyFrame.</p> </li> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> <li> <code>to_path</code>             \u2013              <p>Write pedigree polars.LazyFrame in ped format.</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Variants object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Pedigree.minimal_schema())\n</code></pre>"},{"location":"reference/api/#variantplaner.Pedigree.from_path","title":"from_path","text":"<pre><code>from_path(input_path: Path) -&gt; None\n</code></pre> <p>Read a pedigree file in polars.LazyFrame.</p> <p>Parameters:</p> <ul> <li> <code>input_path</code>               (<code>Path</code>)           \u2013            <p>Path to pedigree file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>A polars.LazyFrame that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def from_path(self, input_path: pathlib.Path) -&gt; None:\n    \"\"\"Read a pedigree file in [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html).\n\n    Args:\n        input_path: Path to pedigree file.\n\n    Returns:\n        A [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) that contains ped information ('family_id', 'personal_id', 'father_id', 'mother_id', 'sex', 'affected')\n    \"\"\"\n    self.lf = polars.scan_csv(\n        input_path,\n        separator=\"\\t\",\n        has_header=False,\n        null_values=[\"None\", \"unknown\"],\n        new_columns=[\n            \"family_id\",\n            \"personal_id\",\n            \"father_id\",\n            \"mother_id\",\n            \"sex\",\n            \"affected\",\n        ],\n        schema_overrides=Pedigree.minimal_schema(),\n    )\n</code></pre>"},{"location":"reference/api/#variantplaner.Pedigree.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>@classmethod\ndef minimal_schema(\n    cls,\n) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"family_id\": polars.String,\n        \"personal_id\": polars.String,\n        \"father_id\": polars.String,\n        \"mother_id\": polars.String,\n        \"sex\": polars.String,\n        \"affected\": polars.Boolean,\n    }\n</code></pre>"},{"location":"reference/api/#variantplaner.Pedigree.to_path","title":"to_path","text":"<pre><code>to_path(output_path: Path) -&gt; None\n</code></pre> <p>Write pedigree polars.LazyFrame in ped format.</p> <p>Warning: This function performs polars.LazyFrame.collect before write csv, this can have a significant impact on memory usage</p> <p>Parameters:</p> <ul> <li> <code>lf</code>           \u2013            <p>LazyFrame contains pedigree information.</p> </li> <li> <code>output_path</code>               (<code>Path</code>)           \u2013            <p>Path where write pedigree information.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul> Source code in <code>src/variantplaner/objects/pedigree.py</code> <pre><code>def to_path(self, output_path: pathlib.Path) -&gt; None:\n    \"\"\"Write pedigree [polars.LazyFrame](https://pola-rs.github.io/polars/py-polars/html/reference/lazyframe/index.html) in ped format.\n\n    Warning: This function performs [polars.LazyFrame.collect][] before write csv, this can have a significant impact on memory usage\n\n    Args:\n        lf: LazyFrame contains pedigree information.\n        output_path: Path where write pedigree information.\n\n    Returns:\n        None\n    \"\"\"\n    self.lf.collect(engine=\"cpu\").write_csv(output_path, include_header=False, separator=\"\\t\")\n</code></pre>"},{"location":"reference/api/#variantplaner.Variants","title":"Variants","text":"<pre><code>Variants(data: LazyFrame | None = None)\n</code></pre> <p>               Bases: <code>LazyFrame</code></p> <p>Object to manage lazyframe as Variants.</p> <p>Methods:</p> <ul> <li> <code>minimal_schema</code>             \u2013              <p>Get schema of variants polars.LazyFrame.</p> </li> </ul> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>def __init__(self, data: polars.LazyFrame | None = None):\n    \"\"\"Initialize a Variants object.\"\"\"\n    if data is None:\n        self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n    else:\n        self.lf = data\n</code></pre>"},{"location":"reference/api/#variantplaner.Variants.minimal_schema","title":"minimal_schema  <code>classmethod</code>","text":"<pre><code>minimal_schema() -&gt; dict[str, type]\n</code></pre> <p>Get schema of variants polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/variants.py</code> <pre><code>@classmethod\ndef minimal_schema(cls) -&gt; dict[str, type]:\n    \"\"\"Get schema of variants polars.LazyFrame.\"\"\"\n    return {\n        \"id\": polars.UInt64,\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n    }\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf","title":"Vcf","text":"<pre><code>Vcf()\n</code></pre> <p>Object to manage lazyframe as Vcf.</p> <p>Methods:</p> <ul> <li> <code>add_genotypes</code>             \u2013              <p>Add genotypes information in vcf.</p> </li> <li> <code>annotations</code>             \u2013              <p>Get annotations of vcf.</p> </li> <li> <code>from_path</code>             \u2013              <p>Populate Vcf object with vcf file.</p> </li> <li> <code>genotypes</code>             \u2013              <p>Get genotype of vcf.</p> </li> <li> <code>schema</code>             \u2013              <p>Get schema of Vcf polars.LazyFrame.</p> </li> <li> <code>set_variants</code>             \u2013              <p>Set variants of vcf.</p> </li> <li> <code>variants</code>             \u2013              <p>Get variants of vcf.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize a Vcf object.\"\"\"\n    self.lf = polars.LazyFrame(schema=Variants.minimal_schema())\n\n    self.header = VcfHeader()\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf.add_genotypes","title":"add_genotypes","text":"<pre><code>add_genotypes(genotypes_lf: Genotypes) -&gt; None\n</code></pre> <p>Add genotypes information in vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def add_genotypes(self, genotypes_lf: Genotypes) -&gt; None:\n    \"\"\"Add genotypes information in vcf.\"\"\"\n    for sample in genotypes_lf.samples_names():\n        geno2sample = (\n            genotypes_lf.lf.filter(polars.col(\"sample\") == sample)\n            .rename(\n                {col: f\"{sample}_{col}\" for col in genotypes_lf.lf.collect_schema().names()[2:]},\n            )\n            .drop(\"sample\")\n        )\n        self.lf = self.lf.join(geno2sample, on=\"id\", how=\"full\", coalesce=True)\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf.annotations","title":"annotations","text":"<pre><code>annotations(\n    select_info: set[str] | None = None,\n) -&gt; Annotations\n</code></pre> <p>Get annotations of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def annotations(self, select_info: set[str] | None = None) -&gt; Annotations:\n    \"\"\"Get annotations of vcf.\"\"\"\n    lf = self.lf.with_columns(self.lf.header.info_parser(select_info))\n\n    return lf.drop(\"chr\", \"pos\", \"ref\", \"alt\", \"format\", \"info\")\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf.from_path","title":"from_path","text":"<pre><code>from_path(\n    path: Path,\n    chr2len_path: Path | None,\n    behavior: VcfParsingBehavior = NOTHING,\n) -&gt; None\n</code></pre> <p>Populate Vcf object with vcf file.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def from_path(\n    self,\n    path: pathlib.Path,\n    chr2len_path: pathlib.Path | None,\n    behavior: VcfParsingBehavior = VcfParsingBehavior.NOTHING,\n) -&gt; None:\n    \"\"\"Populate Vcf object with vcf file.\"\"\"\n    with xopen.xopen(path) as fh:\n        try:\n            self.header.from_lines(fh)\n        except NotVcfHeaderError as e:\n            raise NotAVCFError(path) from e\n\n    chr2len = ContigsLength()\n    if chr2len_path is not None:\n        if chr2len.from_path(chr2len_path) == 0 and chr2len.from_vcf_header(self.header) == 0:\n            raise NoContigsLengthInformationError\n    elif chr2len.from_vcf_header(self.header) == 0:\n        raise NoContigsLengthInformationError\n\n    self.lf = polars.scan_csv(\n        path,\n        separator=\"\\t\",\n        comment_prefix=\"#\",\n        has_header=False,\n        schema_overrides=Vcf.schema(),\n        new_columns=list(Vcf.schema().keys()),\n    )\n\n    schema = self.lf.collect_schema()\n    self.lf = self.lf.rename(dict(zip(schema.names(), self.header.column_name(schema.len()))))\n    self.lf = self.lf.cast(Vcf.schema())  # type: ignore # noqa: PGH003  polars 1.0 typing stuff\n\n    if behavior &amp; VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.with_columns(self.header.info_parser({\"SVTYPE\", \"SVLEN\"}))\n\n    if behavior &amp; VcfParsingBehavior.KEEP_STAR:\n        self.lf = self.lf.filter(polars.col(\"alt\") != \"*\")\n\n    self.lf = normalization.add_variant_id(self.lf, chr2len.lf)\n\n    if behavior &amp; VcfParsingBehavior.MANAGE_SV:\n        self.lf = self.lf.drop(\"SVTYPE\", \"SVLEN\", strict=False)\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf.genotypes","title":"genotypes","text":"<pre><code>genotypes(format_str: str = 'GT:AD:DP:GQ') -&gt; Genotypes\n</code></pre> <p>Get genotype of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def genotypes(self, format_str: str = \"GT:AD:DP:GQ\") -&gt; Genotypes:\n    \"\"\"Get genotype of vcf.\"\"\"\n    schema = self.lf.collect_schema()\n\n    if \"format\" not in schema.names():\n        raise NoGenotypeError\n\n    lf = self.lf.select([*schema.names()[schema.names().index(\"format\") :]])\n    schema = lf.collect_schema()\n\n    # Clean bad variant\n    lf = lf.filter(polars.col(\"format\").str.starts_with(format_str)).select(*schema.names()[1:])\n\n    # Found index of genotype value\n    col_index = {\n        key: index\n        for (index, key) in enumerate(\n            format_str.split(\":\"),\n        )\n    }\n\n    # Pivot value\n    genotypes = Genotypes()\n    genotypes.lf = lf.unpivot(index=[\"id\"]).with_columns(\n        [\n            polars.col(\"id\"),\n            polars.col(\"variable\").alias(\"sample\"),\n            polars.col(\"value\").str.split(\":\"),\n        ],\n    )\n\n    # Split genotype column in sub value\n    col2expr = self.header.format_parser()\n\n    genotypes.lf = genotypes.lf.with_columns(\n        [\n            polars.col(\"value\").list.get(index).pipe(function=col2expr[col], col_name=col)\n            for col, index in col_index.items()\n        ],\n    )\n\n    # Select intrusting column\n    genotypes.lf = genotypes.lf.select([\"id\", \"sample\", *[col.lower() for col in col_index]])\n\n    if \"gt\".upper() in col2expr:\n        genotypes.lf = genotypes.lf.filter(polars.col(\"gt\") != 0)\n\n    return genotypes\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf.schema","title":"schema  <code>classmethod</code>","text":"<pre><code>schema() -&gt; Mapping[str, PolarsDataType]\n</code></pre> <p>Get schema of Vcf polars.LazyFrame.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>@classmethod\ndef schema(cls) -&gt; collections.abc.Mapping[str, polars._typing.PolarsDataType]:\n    \"\"\"Get schema of Vcf polars.LazyFrame.\"\"\"\n    return {\n        \"chr\": polars.String,\n        \"pos\": polars.UInt64,\n        \"vid\": polars.String,\n        \"ref\": polars.String,\n        \"alt\": polars.String,\n        \"qual\": polars.String,\n        \"filter\": polars.String,\n        \"info\": polars.String,\n    }\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf.set_variants","title":"set_variants","text":"<pre><code>set_variants(variants: Variants) -&gt; None\n</code></pre> <p>Set variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def set_variants(self, variants: Variants) -&gt; None:\n    \"\"\"Set variants of vcf.\"\"\"\n    self.lf = variants.lf\n</code></pre>"},{"location":"reference/api/#variantplaner.Vcf.variants","title":"variants","text":"<pre><code>variants() -&gt; Variants\n</code></pre> <p>Get variants of vcf.</p> Source code in <code>src/variantplaner/objects/vcf.py</code> <pre><code>def variants(self) -&gt; Variants:\n    \"\"\"Get variants of vcf.\"\"\"\n    return self.lf.select(Variants.minimal_schema())\n</code></pre>"},{"location":"reference/api/#variantplaner.VcfHeader","title":"VcfHeader","text":"<pre><code>VcfHeader()\n</code></pre> <p>Object that parse and store vcf information.</p> <p>Methods:</p> <ul> <li> <code>column_name</code>             \u2013              <p>Get an iterator of correct column name.</p> </li> <li> <code>format_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract genotypes information.</p> </li> <li> <code>from_files</code>             \u2013              <p>Populate VcfHeader object with content of only header file.</p> </li> <li> <code>from_lines</code>             \u2013              <p>Extract all header information of vcf lines.</p> </li> <li> <code>info_parser</code>             \u2013              <p>Generate a list of polars.Expr to extract variants information.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>contigs</code>               (<code>Iterator[str]</code>)           \u2013            <p>Get an iterator of line contains chromosomes information.</p> </li> <li> <code>samples_index</code>               (<code>dict[str, int] | None</code>)           \u2013            <p>Read vcf header to generate an association map between sample name and index.</p> </li> </ul> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialise VcfHeader.\"\"\"\n    self._header = []\n</code></pre>"},{"location":"reference/api/#variantplaner.VcfHeader.contigs","title":"contigs  <code>cached</code> <code>property</code>","text":"<pre><code>contigs: Iterator[str]\n</code></pre> <p>Get an iterator of line contains chromosomes information.</p> <p>Returns: String iterator</p>"},{"location":"reference/api/#variantplaner.VcfHeader.samples_index","title":"samples_index  <code>cached</code> <code>property</code>","text":"<pre><code>samples_index: dict[str, int] | None\n</code></pre> <p>Read vcf header to generate an association map between sample name and index.</p> <p>Args: header: Header string.</p> <p>Returns: Map that associate a sample name to is sample index.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p>"},{"location":"reference/api/#variantplaner.VcfHeader.column_name","title":"column_name","text":"<pre><code>column_name(\n    number_of_column: int = MINIMAL_COL_NUMBER,\n) -&gt; Iterator[str]\n</code></pre> <p>Get an iterator of correct column name.</p> <p>Returns: String iterator</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def column_name(self, number_of_column: int = MINIMAL_COL_NUMBER) -&gt; typing.Iterator[str]:\n    \"\"\"Get an iterator of correct column name.\n\n    Returns: String iterator\n    \"\"\"\n    base_col_name = [\"chr\", \"pos\", \"vid\", \"ref\", \"alt\", \"qual\", \"filter\", \"info\"]\n\n    yield from base_col_name\n\n    if number_of_column &gt; MINIMAL_COL_NUMBER and (samples := self.samples_index):\n        yield \"format\"\n        yield from (sample for (sample, _) in samples.items())\n</code></pre>"},{"location":"reference/api/#variantplaner.VcfHeader.format_parser","title":"format_parser","text":"<pre><code>format_parser(\n    select_format: set[str] | None = None,\n) -&gt; dict[str, Callable[[Expr, str], Expr]]\n</code></pre> <p>Generate a list of polars.Expr to extract genotypes information.</p> <p>Warning: Float values can't be converted for the moment they are stored as String to keep information</p> <p>Args: header: Line of vcf header. input_path: Path to vcf file. select_format: List of target format field.</p> <p>Returns: A dict to link format id to pipeable function with Polars.Expr</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def format_parser(\n    self,\n    select_format: set[str] | None = None,\n) -&gt; dict[str, typing.Callable[[polars.Expr, str], polars.Expr]]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract genotypes information.\n\n    **Warning**: Float values can't be converted for the moment they are stored as String to keep information\n\n    Args:\n    header: Line of vcf header.\n    input_path: Path to vcf file.\n    select_format: List of target format field.\n\n    Returns:\n    A dict to link format id to pipeable function with Polars.Expr\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    format_re = re.compile(\n        \"ID=(?P&lt;id&gt;[A-Za-z_][0-9A-Za-z_.]*),Number=(?P&lt;number&gt;[ARG0-9\\\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: dict[str, typing.Callable[[polars.Expr, str], polars.Expr]] = {}\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##FORMAT\"):\n            continue\n\n        if (search := format_re.search(line)) and (not select_format or search[\"id\"] in select_format):\n            name = search[\"id\"]\n            number = search[\"number\"]\n            format_type = search[\"type\"]\n\n            if name == \"GT\":\n                expressions[\"GT\"] = VcfHeader.__format_gt\n                continue\n\n            if number == \"1\":\n                if format_type == \"Integer\":\n                    expressions[name] = VcfHeader.__format_one_int\n                elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                    expressions[name] = VcfHeader.__format_one_str\n                elif format_type in {\"String\", \"Character\"}:\n                    expressions[name] = VcfHeader.__format_one_str\n                else:\n                    pass  # Not reachable\n\n            elif format_type == \"Integer\":\n                expressions[name] = VcfHeader.__format_list_int\n            elif format_type == \"Float\":  # noqa: SIM114 Float isn't already support but in future\n                expressions[name] = VcfHeader.__format_list_str\n            elif format_type in {\"String\", \"Character\"}:\n                expressions[name] = VcfHeader.__format_list_str\n            else:\n                pass  # Not reachable\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/api/#variantplaner.VcfHeader.from_files","title":"from_files","text":"<pre><code>from_files(path: Path) -&gt; None\n</code></pre> <p>Populate VcfHeader object with content of only header file.</p> <p>Args: path: Path of file</p> <p>Returns: None</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_files(self, path: pathlib.Path) -&gt; None:\n    \"\"\"Populate VcfHeader object with content of only header file.\n\n    Args:\n    path: Path of file\n\n    Returns:\n    None\n    \"\"\"\n    with open(path) as fh:\n        for full_line in fh:\n            line = full_line.strip()\n            self._header.append(line)\n</code></pre>"},{"location":"reference/api/#variantplaner.VcfHeader.from_lines","title":"from_lines","text":"<pre><code>from_lines(lines: Iterator[str]) -&gt; None\n</code></pre> <p>Extract all header information of vcf lines.</p> <p>Line between start of file and first line start with '#CHROM' or not start with '#'</p> <p>Args: lines: Iterator of line</p> <p>Returns: None</p> <p>Raises: NotAVcfHeader: If a line not starts with '#' NotAVcfHeader: If no line start by '#CHROM'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def from_lines(self, lines: typing.Iterator[str]) -&gt; None:\n    \"\"\"Extract all header information of vcf lines.\n\n    Line between start of file and first line start with '#CHROM' or not start with '#'\n\n    Args:\n    lines: Iterator of line\n\n    Returns: None\n\n    Raises:\n    NotAVcfHeader: If a line not starts with '#'\n    NotAVcfHeader: If no line start by '#CHROM'\n    \"\"\"\n    for full_line in lines:\n        line = full_line.strip()\n\n        if not line.startswith(\"#\"):\n            raise NotVcfHeaderError\n\n        if line.startswith(\"#CHROM\"):\n            self._header.append(line)\n            return\n\n        self._header.append(line)\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/api/#variantplaner.VcfHeader.info_parser","title":"info_parser","text":"<pre><code>info_parser(\n    select_info: set[str] | None = None,\n) -&gt; list[Expr]\n</code></pre> <p>Generate a list of polars.Expr to extract variants information.</p> <p>Args: header: Line of vcf header input_path: Path to vcf file. select_info: List of target info field</p> <p>Returns: List of polars.Expr to parse info columns.</p> <p>Raises: NotVcfHeaderError: If all line not start by '#CHR'</p> Source code in <code>src/variantplaner/objects/vcf_header.py</code> <pre><code>def info_parser(self, select_info: set[str] | None = None) -&gt; list[polars.Expr]:\n    \"\"\"Generate a list of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to extract variants information.\n\n    Args:\n    header: Line of vcf header\n    input_path: Path to vcf file.\n    select_info: List of target info field\n\n    Returns:\n    List of [polars.Expr](https://pola-rs.github.io/polars/py-polars/html/reference/expressions/index.html) to parse info columns.\n\n    Raises:\n    NotVcfHeaderError: If all line not start by '#CHR'\n    \"\"\"\n    info_re = re.compile(\n        r\"ID=(?P&lt;id&gt;([A-Za-z_][0-9A-Za-z_.]*|1000G)),Number=(?P&lt;number&gt;[ARG0-9\\.]+),Type=(?P&lt;type&gt;Integer|Float|String|Character)\",\n    )\n\n    expressions: list[polars.Expr] = []\n\n    for line in self._header:\n        if line.startswith(\"#CHROM\"):\n            return expressions\n\n        if not line.startswith(\"##INFO\"):\n            continue\n\n        if (search := info_re.search(line)) and (not select_info or search[\"id\"] in select_info):\n            regex = rf\"{search['id']}=([^;]+);?\"\n\n            local_expr = polars.col(\"info\").str.extract(regex, 1)\n\n            if search[\"number\"] == \"1\":\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.Int64)\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.Float64)\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            else:\n                local_expr = local_expr.str.split(\",\")\n                if search[\"type\"] == \"Integer\":\n                    local_expr = local_expr.cast(polars.List(polars.Int64))\n                elif search[\"type\"] == \"Float\":\n                    local_expr = local_expr.cast(polars.List(polars.Float64))\n                elif search[\"type\"] in {\"String\", \"Character\"}:\n                    pass  # Not do anything on string or character\n                else:\n                    pass  # Not reachable\n\n            expressions.append(local_expr.alias(search[\"id\"]))\n\n    raise NotVcfHeaderError\n</code></pre>"},{"location":"reference/api/#variantplaner.VcfParsingBehavior","title":"VcfParsingBehavior","text":"<p>               Bases: <code>IntFlag</code></p> <p>Enumeration use to control behavior of IntoLazyFrame.</p> <p>Attributes:</p> <ul> <li> <code>KEEP_STAR</code>           \u2013            <p>Keep star variant.</p> </li> <li> <code>MANAGE_SV</code>           \u2013            <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p> </li> <li> <code>NOTHING</code>           \u2013            <p>into_lazyframe not have any specific behavior</p> </li> </ul>"},{"location":"reference/api/#variantplaner.VcfParsingBehavior.KEEP_STAR","title":"KEEP_STAR  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>KEEP_STAR = auto()\n</code></pre> <p>Keep star variant.</p>"},{"location":"reference/api/#variantplaner.VcfParsingBehavior.MANAGE_SV","title":"MANAGE_SV  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>MANAGE_SV = auto()\n</code></pre> <p>into_lazyframe try to avoid structural variant id collision, SVTYPE/SVLEN info value must be present.</p>"},{"location":"reference/api/#variantplaner.VcfParsingBehavior.NOTHING","title":"NOTHING  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>NOTHING = auto()\n</code></pre> <p>into_lazyframe not have any specific behavior</p>"},{"location":"coverage/","title":"Coverage report","text":""}]}